/*
 * -----------------------
 * ------ SMART APP ------
 * -----------------------
 *
 * STOP:  Do NOT PUBLISH the code to GitHub, it is a VIOLATION of the license terms.
 * You are NOT allowed to modify, share, distribute, reuse or publicly host (e.g. GITHUB) the code. Refer to the license details on our website.
 *
 */

/* **DISCLAIMER**
* THIS SOFTWARE IS PROVIDED "AS IS" AND ANY EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
* HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Without limitation of the foregoing, Contributors/Regents expressly does not warrant that:
* 1. the software will meet your requirements or expectations;
* 2. the software or the software content will be free of bugs, errors, viruses or other defects;
* 3. any results, output, or data provided through or generated by the software will be accurate, up-to-date, complete or reliable;
* 4. the software will be compatible with third party software;
* 5. any errors in the software will be corrected.
* The user assumes all responsibility for selecting the software and for the results obtained from the use of the software. The user shall bear the entire risk as to the quality and the performance of the software.
*/ 

def clientVersion() { "04.08.00" }

/**
* Rental Lock Automater (RLA) - Automate lock user management for rental listing properties (AirBnB, Vrbo, HomeAway, Booking, TripAdvisor, Expedia, Generic iCal)
*
* Copyright RBoy Apps, redistribution, modification or reuse of code is not allowed without permission
*
* Change Log:
* 2021-05-05 - (v04.08.00) Increase limit to 12 properties, add start/end time offset for custom calendars
* 2021-03-20 - (v04.07.01) Support for cipher changes to AirBnB and other calendars
* 2021-03-05 - (v04.06.01) If phone markers are missing from custom calendar, don't generate code
* 2021-03-04 - (v04.06.00) Fix for HomeAway, VRBO, Custom managers (Villas365) not working due to lack of GCM ciphers
* 2021-03-03 - (v04.05.05) Fix for custom channel manager not parsing multi line DESCRIPTION correctly
* 2021-03-02 - (v04.05.04) ADT deprecated by SmartThings
* 2021-02-18 - (v04.05.03) Include identifier in header while calling custom channel managers
* 2021-02-05 - (v04.05.02) Improve description of phone markers
* 2020-12-23 - (v04.05.00) Added support to process phone numbers from multi line DESCRIPTION
* 2020-12-22 - (v04.04.01) Process delayed phone entries from Airbnb iCal
* 2020-12-02 - (v04.04.00) Added support for custom phone markers in iCalendar
* 2020-11-16 - (v04.03.01) Skip door if the user accidentally left out the open door notify or relock timeout
* 2020-10-30 - (v04.03.00) Add support for reading start/end time from custom calendars, added support for WiFi/radiator thermostats, FAQ link, Don't update user codes after they generated even if reservation dates change
* 2020-10-27 - (v04.02.02) Check for invalid DTH
* 2020-10-26 - (v04.02.01) Fix extra space and date change message
* 2020-10-19 - (v04.02.00) Refresh users page once a minute to see user status updates
* 2020-10-06 - (v04.01.09) Don't enable ADT direct control by default when a keypad is detected
* 2020-10-05 - (v04.01.08) Fix 0 digit warning from some locks, added option to manually clear codes from the lock from advanced settings, show warning if user type isn't selected
* 2020-10-01 - (v04.01.06) Fix missing initial lock notification when using a delay timer
* 2020-09-15 - (v04.01.05) Update garage door controls to support new capabilities
* 2020-09-08 - (v04.01.04) Update for new platform capability model
* 2020-09-01 - (v04.01.03) Update for retirement of Classic app
* 2020-08-19 - (v04.01.02) Add option to arm ADT to away for manual locking
* 2020-08-17 - (v04.01.01) Only post one message when locks stop responding
* 2020-08-14 - (v04.01.00) Added ability to manually override automatic user codes, clear all manual adjustments to automatic codes after a "Clear Codes" procedure is detected
* 2020-08-11 - (v04.00.05) Detect deleted routines after a migration
* 2020-08-10 - (v04.00.04) Improve explanation of phone number in custom calendar "DESCRIPTION" field
* 2020-08-05 - (v04.00.03) Dont' send code upgrade notifications
* 2020-07-29 - (v04.00.02) Fix for Door open/close actions when using multiple doors on Android Classic app
* 2020-07-24 - (v04.00.00) Added Generic iCal integration, Show the year for expiration users on summary page, sort entries by date while reading iCal
* 2020-06-22 - (v03.10.00) Added Expedia iCal integration, Optimized page layout for door open/close actions when multiple locks are selected, trim iCal URL for extra spaces
* 2020-05-22 - (v03.09.00) Added option to lock/unlock locks for presence users and disabled auto unlock for open doors (security)
* 2020-05-01 - (v03.08.00) Added option to toggle switches on keypad lock/unlock/arm modes
* 2020-04-02 - (v03.07.01) Fix for keypad lock report for Enhanced ZigBee device handler
* 2020-02-12 - (v03.07.00) Added option for random code generation, increased default iCal sync to 2 hours, adjustable, manually sync iCal only when property page is opened and after code upgrade
* 2020-02-05 - (v03.06.00) Added more check-in/out actions for new ST app
* 2020-01-20 - (v03.05.03) Update icons for broken ST Android app 2.18
* 2019-12-03 - (v03.05.02) Better identification for new Airbnb format, display critical update messages when available
* 2019-11-27 - (v03.05.00) Update for changes in platform limits, optimize performance, support for new Airbnb calendar format
* 2019-11-20 - (v03.04.03) Check for invalid calendar entry key, handle icalendar redirects
* 2019-11-18 - (v03.04.01) Optimize UI speed, set default to 5 users
* 2019-11-05 - (v03.04.00) Sync base engine with 07.10.00, increased max manual users limit to 200
* 2019-10-11 - (v03.03.00) Added support for Sonos spoken notification with volume, added option to disable rechecking and notifying open door
* 2019-10-02 - (v03.02.12) Disable SMS due to ST stopping international SMS and AirBnB upcoming calendar changes
* 2019-08-12 - (v03.02.11) Correct missing geolocation message text
* 2019-06-20 - (v03.02.10) Tell ST to use sentence capitalization for custom SMS messages
* 2019-06-03 - (v03.02.09) Added support for new lock capabilities
* 2019-05-27 - (v03.02.08) Limit checkin/out actions offset to 24 hours, skip checkout actions if scheduled after checkin actions, fix issue with automatic users notifications limit not being honored
* 2019-05-14 - (v03.02.05) Handle redirects from sites using ST Async bug workaround
* 2019-04-22 - (v03.02.04) More flexible to handle minor changes in calendar formats without having to update RLA
* 2019-04-21 - (v03.02.03) Updated AirBnB format, skip names with Not available
* 2019-04-16 - (v03.02.02) Fix optional text for ADT
* 2019-04-12 - (v03.02.01) Separate iCalendar url's for HomeAway and Vrbo, fixed TripAdvisor icon, show property locks option even if there's only 1 lock available, check if user entered invalid characters for SMS number and notify on error
* 2019-04-10 - (v03.01.02) Don't schedule check in/out actions if the automatic user doesn't have a code (incomplete booking)
* 2019-04-09 - (v03.01.01) Added option in usage history page to show all lock events
* 2019-04-08 - (v03.01.00) Added 7 day user lock/unlock usage history page
* 2019-04-03 - (v03.00.05) Enable exit beeping on keypads using direct control for SHM/ADT when delayed actions are enabled
* 2019-04-02 - (v03.00.04) Check for updates once a day and don't reset it everytime the user opens the app, allow the user to select the number of digits for the user/pin codes when the lock supports it, allow user to save without selecting locks
* 2019-03-27 - (v03.00.01) Improved support for an early check out reservation date change and don't schedule/run checkin/out actions if automatic users are disabled
* 2019-03-22 - (v03.00.00) Added support for automatic CheckIn/CheckOut actions and show active users in green instead of blue, new automatic user slot management, don't move existing codes between slots when synchronizing with calendar changes
* 2019-03-08 - (v02.03.09) Fixed extra notifications when using delayed lock actions
* 2019-02-28 - (v02.03.08) Enabled keypad SHM/ADT control by default when detected
* 2019-02-08 - (v02.03.07) Send automatic code SMS code and invalid code notification only within time restrictions and use hub timezone instead of phone timezone for automatic code notifications
* 2019-01-28 - (v02.03.06) Fix for direct control option not showing for renamed keypads when individual door controls are enabled
* 2019-01-13 - (v02.03.05) Check for unsaved/unintialized user changes and reinitialize the app automatically
* 2018-12-18 - (v02.03.04) Increase max property limit to 10 units
* 2018-12-13 - (v02.03.03) Reduce frequency to kickstarts since platform is more stable and reduce frequency of download rental data to improve tripadvisor synchronization
* 2018-12-05 - (v02.03.02) Sync calendars every 60 minutes due to rate limitations from TripAdvisor
* 2018-12-04 - (v02.03.01) Improve UI layout, separate page for notifications
* 2018-11-28 - (v02.03.00) Sync up with base engine version 07.08.00 and added support for TripAdvisor calendars
* 2018-11-25 - (v02.02.05) Sync up with base engine version 07.07.08
* 2018-11-12 - (v02.02.04) Skip pending reservations on AirBnB, wait for confirmed status before generating user/code
* 2018-10-18 - (v02.02.03) Notify owner about sending SMS to renters and any errors with SMS at anytime (don't limit to notification schedule)
* 2018-10-16 - (v02.02.02) Patch for ST platform not following iCalendar redirects for some servers, handle it internally
* 2018-10-10 - (v02.02.01) Improve notification message if the iCalendar server is offline
* 2018-10-09 - (v02.02.00) Fixed and issue where the start date of would go back a month if the preactivation date was > 0, SMS messages will now use reservation dates (original or manually udpated) and not activation dates
* 2018-10-03 - (v02.01.01) Improved logging booking.com
* 2018-09-20 - (v02.01.00) Added support for Booking.com, baseline Sure Programming Engine 07.07.06
* 2018-09-03 - (v02.00.14) Clear excess users settings when reducing the number of automatic users, detect if check in/out time and pre activation days were changed and adjust accordingly, notify if renter is missing code/phone number
* 2018-08-29 - (v02.00.12) Improve compatibility with new ST app, added default expiration date for new users, simplified text
* 2018-08-20 - (v02.00.11) Check for code updates everyday and improve layout of automatic relock text
* 2018-08-01 - (v02.00.09) Added support for Arming/disarming ADT and resume playing the audio after notifications
* 2018-07-31 - (v02.00.08) More stingent validation for date entry format
* 2018-07-25 - (v02.00.07) Update Sure Programming Engine to 07.06.06, detect if someone accidentally added a code from another app and delete it
* 2018-07-25 - (v02.00.06) Reduce memory usage since ST has reduced limit on platform, helps with multi unit rentals
* 2018-07-22 - (v02.00.03) VRBO/AirBnB/HomeAway only use secure iCalendar URL's now, so if user enters a http URL convert to https
* 2018-07-19 - (v02.00.02) Notify user if AirBnB/VRBO websites return an error or no reservation details
* 2018-07-11 - (v02.00.01) Allow smooth upgrade from v1 app
* 2018-07-10 - (v02.00.00) Release 2.0
* 2018-07-09 - (v01.01.11) Sync up based to 07.06.04 and skip entries with invalid dates
* 2018-07-08 - (v01.01.10) Enforce platform limits for manual and rental users to prevent UI timeout
* 2018-07-07 - (v01.01.09) Ignore schedules changes for old reservations
* 2018-07-06 - (v01.01.08) Add property name while displaying rather than in the name itself, performance optimization for UI and look for VRBO schedule changes also
* 2018-07-05 - (v01.01.06) Keep reservation id's with name since we look up by name to send SMS and manage users, user names have to be unique
* 2018-07-05 - (v01.01.04) Check for updates to reservation dates and add property name to reservation user name
* 2018-06-30 - (v01.01.03) Sync up with base app v07.06.03 and add functionality for multi rental units
* 2018-06-21 - (v01.01.02) Added option to override checkin/checkout date and time for each user
* 2018-06-20 - (v01.01.01) Check for SmartApp updates daily
* 2018-06-20 - (v01.01.00) Use TLS 1.2 to fix VRBO/Homeaway connection issues after recent website update
* 2018-05-31 - (v01.00.06) Correct RFID case to capitals
* 2018-05-29 - (v01.00.05) Save lock id's instead of names when selecting per user locks to avoid issue of renamed locked/locks with similar names (requires users to reselect locks) and use sensor name instead of lock name for reporting open doors
* 2018-05-14 - (v01.00.04) Ignore case of <code>, <start> and <end> in SMS template, some phones automatically change case, e.g. <code> to <Code>, when typing the message
* 2018-05-11 - (v01.00.03) Update for platform not saving sms settings for individual users
* 2018-05-07 - (v01.00.02) Increase max retries limit to 999 and default to 15 to allow for weak mesh or intermittent internet connectivity at remote locations
* 2018-05-01 - (v01.00.01) Patch for removing burner codes when multiple locks are used simultaneously
* 2018-04-18 - (v01.00.00) Public release
* 2016-08-04 - (v00.00.01) Initial release
*
*/

definition(
    name: "Rental Lock Automater",
    namespace: "rboy",
    author: "RBoy Apps",
    description: "Automate lock user management for rental listing properties (AirBnB, Vrbo, HomeAway, Booking, TripAdvisor, Expedia etc)",
    category: "Safety & Security",
    iconUrl: "https://www.rboyapps.com/images/LockAutomater.png",
    iconX2Url: "https://www.rboyapps.com/images/LockAutomater.png"
)

preferences {
    page(name: "loginPage")
    page(name: "loginPage2")
    page(name: "setupApp")
    page(name: "usersPage")
    page(name: "notificationsPage")
    page(name: "unlockLockActionsPage")
    page(name: "unlockKeypadActionsPage")
    page(name: "unlockManualActionsPage")
    page(name: "armKeypadActionsPage")
    page(name: "lockKeypadActionsPage")
    page(name: "lockManualActionsPage")
    page(name: "openCloseDoorPage")
    page(name: "openCloseDoorPageSummary")
    page(name: "scheduleCodesPage")
    page(name: "userConfigPage")
    page(name: "userHistoryPage")
    page(name: "rentalIntegrationPage")
    page(name: "propertyURLPage")
    page(name: "genericURLPage")
    page(name: "checkInOutActionsPage")
}

include 'asynchttp'

private getProxyURL() { "http://rla.rboyapps.com:82/?" } // SmartThings doesn't support GCM security ciphers required by some sites, strengthen it
private getIdentifier() { "RLA" } // Unique identifier to include in header while calling servers
private getSendCodeToPhone() { "" } // Disable SMS for now since ST no longer sends SMS to international numbers and upcoming AirBnB calendar changes
private getAddReservationIdToName() { true } // Name has to be unique so add , you can have multiple users with same name on same property
private getMinSendCodeToPhoneDays() { 1 } // Minimum days to send SMS to user
private getDefaultRentalUpdateFrequency() { 2 } // Default update rental schedules every 2 hours (some sites like TripAdvisor hit limits AirBnB is 80/min per IP)
private getRentalUpdateFrequency() { ((iCalUpdateFrequency ?: defaultRentalUpdateFrequency) * 60) as Integer } // Update rental schedules every X minutes
private getDefaultSendDelay() { 15 }
private getDefaultRetries() { 15 }
private getMaxRetries() { retries == null ? defaultRetries : (retries as Integer) }
private getMaxOffsetActions() { (24 * 60) as Integer } // Maximum offset in minutes for CheckIn and CheckOut actions
private getMaxExtendDays() { 1 } // Maximum number of days a reservation can be manually extended (should be minimum 1 so that CheckOut actions can run after users expire)
private getDefaultRentalUnitsCount() { 1 } // 1 unit by default
private getMaxRentalUnitsCount() { 12 } // Too many units may cause ST to run out of memory for a single instance when downloading data
private getDefaultRentalDays() { 7 } // Process 7 days of booking schedules by default
private getDefaultManualUsers() { 5 } // 5 manual user by default
private getDefaultRentalUsers() { 5 } // 5 automatic rental users by default (one checking in and one checking out)
private getMaxRentalDays() { 999 } // By default process 999 days of calendar schedule/entries for the property
private getMaxUserNames() { ((maxManualUsers as Integer) ?: 0) + ((maxRentalUsers as Integer) ?: 0) } // Total maximum number of users = Rental Users + Manual Users
private getMaxPreArrivalDays() { 5 } // Activate the codes upto 5 days ahead of arrival (a high number creates too many active codes and causes problems with Kwikset locks like 910/912)
private getDefaultPreArrivalDays() { 0 } // Activate the codes on the day of arrival
private getPreArrivalActivationDays() { rentalPreArrivalActivationDays == null ? defaultPreArrivalDays : rentalPreArrivalActivationDays } // Number of days ahead to arrival to activate codes
private getMaxAutoPinLen() { 8 } // Maximum pin length for automatically generated pin codes
private getMinAutoPinLen() { 4 } // Minimum pin length for automatically generated pin codes
private getPlatformManualUsersLimit() { 200 } // Any more and the platform times out while trying to load the UI (max 200)
private getPlatformRentalUsersLimit() { 50 } // Any more and the platform times out while trying to load the UI (max 100), also impacts spaced used to store calendar data
private getManualUsersLimit() { maxCodes ? Math.min(platformManualUsersLimit, maxCodes - (maxRentalUsers ?: 0)) : platformManualUsersLimit } // Don't exceed platform limits
private getRentalUsersLimit() { maxCodes ? Math.min(platformRentalUsersLimit, maxCodes - (maxManualUsers ?: 0)) : platformRentalUsersLimit } // Don't exceed platform limits
private getSchedulesSuffix() { ('A'..'C') }
private getGenericCalendarTimeOffsets() { [ "0":"Use reservation time", "5":"5 min", "10":"10 min", "15":"15 min", "30":"30 min", "60":"60 min" ] } // Custom calendar time offset for start/end times
private getCodeOptions() {
    [
        "Permanent": "Permanent",
        "One time": "One time (burner)",
        "Expire on": "Start/end date and time",
        "Scheduled": "Weekly/daily schedule(s)",
        "Presence": "Activate on user presence",
        "Modes": "Activate on mode(s)",
        "Inactive": "Temporarily disabled"
    ]
}
private getSchedulingOptions() {
    [
        'All Week',
        'Monday to Friday',
        'Saturday & Sunday',
        'Monday',
        'Tuesday',
        'Wednesday',
        'Thursday',
        'Friday',
        'Saturday',
        'Sunday'
    ]
}

def loginPage() {
    log.trace "Login page"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage", "loginPage2")
    }
}

def loginPage2() {
    log.trace "Login page2"
    if (!state.loginSuccess && username) {
        loginCheck()
    }
    if (state.loginSuccess) {
        setupApp()
    } else {
        state.sendUpdate = true
        loginSection("loginPage2", "loginPage")
    }
}

private loginSection(name, nextPage) {
    dynamicPage(name: name, title: "Rental Lock Automater v${clientVersion()}", install: state.loginSuccess, uninstall: true, nextPage: state.loginSuccess ? "" : nextPage) {
        section() {
            if (state.loginError) {
                log.warn "Authenticating failed: ${state.loginError}"
                paragraph title: "Login failed", image: "https://www.rboyapps.com/images/RBoyApps.png", required: true, "${state.loginError}"
            } else {
                log.debug "Check authentication credentials, Login: $username"
                paragraph title: "Login", image: "https://www.rboyapps.com/images/RBoyApps.png", required: false, "Enter your RBoy Apps username\nYou can retrieve your username from www.rboyapps.com lost password page"
            }

            input name: "username", type: "text", title: "Username", capitalization: "none", submitOnChange: false, required: false
        }
    }
}

def setupApp() {
    log.trace "$settings"

    dynamicPage(name: "setupApp", title: "Rental Lock Automater v${clientVersion()}", install: true, uninstall: true) {
        if (state.clientVersion) { // If the app has already been installed
            section("Select Locks") {
                // Check if the lock pin code length match on all the locks
                def pinDetails = getLockPinLengthDetails()
                def pinLen = pinDetails.pinLen // Fixed pin code length
                def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
                def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
                def pinLenError = pinDetails.pinLenError
                log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"
                if (pinLenError) {
                    def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING MAY FAIL!"
                    paragraph title: msg, required: true, ""
                }
                for (lock in locks) {
                    if (!lock.hasCommand("setCode")) {
                        def msg = "${lock} IS USING A DEVICE HANDLER WHICH DOES NOT SUPPORT PROGRAMMING!"
                        paragraph title: msg, required: true, ""
                    }
                }
                input "locks", "capability.lock", title: "Locks", description: "Select all locks to manage", required: false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/HandleLock.png"
            }

            section("User/Property Management${maxCodes ? " (Max ${Math.min(maxCodes, platformManualUsersLimit + platformRentalUsersLimit)} users)" : ""}") {
                log.trace "state.previousMaxManualUsers: ${state.previousMaxManualUsers?.inspect()}, maxManualUsers: ${maxManualUsers?.inspect()}"
                // Bug in ST Classic app, if users presses back on new installation without pressing Save, it saves the default values as a String
                if (maxManualUsers && (state.previousMaxManualUsers != null) && ((state.previousMaxManualUsers as Integer) < (maxManualUsers as Integer))) { // If the number of max manual users has increased, then clear the new slots, if previous is null, it isnt' initialized, so we need to initialize it
                    log.debug "Detected an increase in number of maxManualUsers, clearing user slots ${(state.previousMaxManualUsers as Integer) + 1} to ${(maxManualUsers as Integer)}"
                    startTimer(1, removeRentalUsersOffline, [ data: [start: ((state.previousMaxManualUsers as Integer) + 1), end: (maxManualUsers as Integer)] ]) // Clear the slots
                } // Clear new users offline so it doesn't slow down the UI (do it while reducing users so that when you increase the slots are already cleared)

                log.trace "state.previousMaxUserNames: ${state.previousMaxUserNames?.inspect()}, maxUserNames: ${maxUserNames?.inspect()}"
                if ((maxUserNames != null) && (state.previousMaxUserNames as Integer) > (maxUserNames as Integer)) { // If the number of max users has reduced, then clear excess the slots
                    log.debug "Detected a reduction in number of maxUserNames, clearing rental user slots ${(maxUserNames as Integer) + 1} to ${(state.previousMaxUserNames as Integer)}"
                    startTimer(1, removeRentalUsersOffline, [ data: [start: ((maxUserNames as Integer) + 1), end: (state.previousMaxUserNames as Integer)] ]) // Clear the slots
                } // Clear excess users offline so it doesn't slow down the UI (do it while reducing users so that when you increase the slots are already cleared)

                log.trace "state.previousMaxRentalUsers: ${state.previousMaxRentalUsers?.inspect()}, maxRentalUsers: ${maxRentalUsers?.inspect()}"
                if (maxRentalUsers && (state.previousMaxRentalUsers != null) && ((state.previousMaxRentalUsers as Integer) < (maxRentalUsers as Integer))) { // If the number of max rental users has increased, then trigger an update since we only save as much as data as max rental users
                    if (locks) {
                        log.debug "Detected an increase in number of maxRentalUsers, downloading rental data"
                        downloadRentalData() // Start the background download of data if present
                        state.refreshedData = true // We've downloaded
                    }
                } else { // Check if we need to download rental data
                    if (locks && !state.refreshedData) {
                        downloadRentalData() // Start the background download of data if present
                        state.refreshedData = true // We've downloaded
                    }
                }

                // If there are no rental users defined, there may be a clear codes procedure in effect, reset all manual adjustments
                if (!maxRentalUsers) {
                    log.debug "${maxRentalUsers} automatic users detected. Clearing all manual adjustments to automatic users"
                    state.updatedUsers = []
                }
                
                state.previousMaxManualUsers = maxManualUsers as Integer // Reset it (bug on a fresh install ST sometimes stores it as a String)
                state.previousMaxRentalUsers = maxRentalUsers as Integer // Reset it (bug on a fresh install ST sometimes stores it as a String)
                state.previousMaxUserNames = maxUserNames as Integer // Reset it (bug on a fresh install ST sometimes stores it as a String)

                log.trace "Max common codes supported by locks ${maxCodes}"
                paragraph "Set the number of programmable users\n(0 to disable)"
                input name: "maxManualUsers", title: "Manual users${maxCodes ? " (0 - ${manualUsersLimit})" : ""}", type: "number", defaultValue: defaultManualUsers, required: true, multiple: false, image: "https://www.rboyapps.com/images/Users.png", range: "0..${maxCodes ? manualUsersLimit : platformManualUsersLimit}", submitOnChange: true
                input name: "maxRentalUsers", title: "Automatic users${maxCodes ? " (0 - ${rentalUsersLimit})" : ""}", type: "number", defaultValue: defaultRentalUsers, required: true, multiple: false, image: "https://www.rboyapps.com/images/Users.png", range: "0..${maxCodes ? rentalUsersLimit : platformRentalUsersLimit}", submitOnChange: true

                href(name: "integration", title: "Manage property", page: "rentalIntegrationPage", description: "Integration with AirBnB, Vrbo, HomeAway, Booking, TripAdvisor, Expedia etc", required: false, image: "https://www.rboyapps.com/images/Property.png")
                href(name: "users", title: "Manage users", page: "usersPage", description: "Review users and custom actions", required: false, image: "https://www.rboyapps.com/images/UserPage.png")
                href(name: "userHistory", params: hrefParams, title: "Usage history", page: "userHistoryPage", description: "", required: false, image: "https://www.rboyapps.com/images/UsageHistory.png")
            }

            section("General Settings") {
                // Unlock actions for all users (global)
                def hrefParams = [
                    user: null, 
                    passed: true 
                ]
                href(name: "unlockLockActions", params: hrefParams, title: "Lock/unlock actions", page: "unlockLockActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/LockUnlock.png")
                href(name: "openCloseDoorSummary", title: "Door open/close actions", page: "openCloseDoorPageSummary", description: "", required: false, image: "https://www.rboyapps.com/images/DoorOpenClose.png")
                href(name: "notifications", params: hrefParams, title: "Notifications", page: "notificationsPage", description: "", required: false, image: "https://www.rboyapps.com/images/NotificationsD.png")
            }

            section("Help") {
                href(name: "help", title: "FAQ", description: "Frequently asked questions", style: "external", url: "https://smartthings.rboyapps.com/RLA-FAQ.htm", required: false, image: "https://www.rboyapps.com/images/FAQ.png")
            }

            section() {
                label title: "Assign a name for this SmartApp (optional)", required: false
                input name: "updateNotifications", title: "Check for new versions of the app", type: "bool", defaultValue: true, required: false
            }

            section("Advanced Programming Options (optional)", hideable: true, hidden: true) {
                paragraph "Adjust the iCalendar synchronization interval, making this too often can cause the server to temporarily block access"
                input name: "iCalUpdateFrequency", title: "How often to update reservations (hours)", type: "number", defaultValue: "${defaultRentalUpdateFrequency}", range: "1..48", required: false
                paragraph "Sure-Programming: To improve programming reliability, the app will keep trying to program the user codes until the lock confirms the programming or up to the maximum number of retries"
                input name: "retries", title: "Maximum code programming retries", type: "number", defaultValue: "${defaultRetries}", range: "0..999", required: false
                paragraph "Change this setting if all the user codes aren't being programmed on the lock correctly. This settings determines the time gap between sending each user code to the lock. If the codes are sent too fast, they may fail to be set properly"
                input name: "sendDelay", title: "Delay between codes (seconds):", type: "number", defaultValue: "${defaultSendDelay}", range: "5..60", required: false
                paragraph "Enable this to get additional detailed notifications like code programming, lock responses etc. NOTE: this can generate a lot of messages"
                input name: "detailedNotifications", title: "Get detailed notifications", type: "bool", defaultValue: false, required: false
                paragraph ""
                paragraph title: "[WARNING] CLEAR USER CODES", "ENABLING THIS OPTION WILL CLEAR THE FIRST ${(maxUserNames as Integer) ?: 0} USER CODES FROM EACH OF THE LOCKS SELECTED ABOVE. AFTER ENABLING THIS OPTION, CLICK 'DONE' AND WAIT FOR THE CLEARING TO TAKE EFFECT", required: true
                input name: "clearUserCodes", title: "CLEAR EXISTING USER CODES", type: "bool", defaultValue: false, required: false
            }
        } else {
            section() {
                paragraph "Click 'Done' to install the app. Then you can open it from the 'SmartApps' tab to finish configuring it.\r\n\r\nEnsure that there is a buffering device between your lock and hub. See FAQ page for more details."
                label title: "Assign a name for this SmartApp (optional)", required: false
            }
        }
        
        section("Confidential", hideable: true, hidden: true) {
            paragraph("RBoy Apps Username: " + (username?.toLowerCase() ?: "Unlicensed") + (state.loginSuccess ? "" : ", contact suppport"))
        }

        remove("Uninstall")
    }
}

def userHistoryPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "User History Page, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"userHistoryPage", title: "7 Day Usage History", uninstall: false, install: false) {
        if (locks) {
            section() {
                input "showAllLockUnlockEvents", "bool", title: "Show all events", required: false, defaultValue: false, submitOnChange: true
            }
        } else {
            section("Invalid locks") {
                paragraph title: "First select the locks on the previous page", required: true, ""
            }
        }
        
        for (lock in locks) {
            def events = (lock.eventsSince((new Date(now())) - 30, [max: 1000]))?.findAll { ((showAllLockUnlockEvents ? ["invalidCode", "unknown"] : []) + ["lock", "unlock"]).contains(it.name) && (showAllLockUnlockEvents ? true : it.descriptionText?.contains("by")) } // ST limits it to 7 days and only look for lock and unlock events but lets ask for 30
            section (lock.displayName) {
                def text = events.collect { it.date?.format("MMM d H:m", location.timeZone ?: TimeZone.getDefault()) + " " + it.descriptionText?.replace('"', "") }?.join("\n")
                if (text) {
                    paragraph text
                }
            }
        }
    }
}

def notificationsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Notifications Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"notificationsPage", title: (user ? "Setup custom notifications for ${name ?: "user ${user}"}" : "Setup notification options"), uninstall: false, install: false) {
        section {
            input "audioDevices${user}", "capability.audioNotification", title: "Speak notifications on", required: false, multiple: true, submitOnChange: true, image: "https://www.rboyapps.com/images/Horn.png"
            if (settings."audioDevices${user}") {
                input "audioVolume${user}", "number", title: "...at this volume level (optional)", description: "keep current", required: false, range: "1..100"
            }
            input("recipients${user}", "contact", title: "Send notifications to", multiple: true, required: false, image: "https://www.rboyapps.com/images/Notifications.png") {
                paragraph "You can enter multiple phone numbers by separating them with a '*'\nE.g. 5551234567*+18747654321"
                input "sms${user}", "phone", title: "Send SMS notification to", required: false, image: "https://www.rboyapps.com/images/Notifications.png"
                input "disableAllNotify${user}", "bool", title: "Disable all push notifications${user ? " for " + (name ?: "user ${user}") : ""}", defaultValue: false, required: false
            }
        }
    }
}

def checkInOutActionsPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def no = params?.no ?: 0
    def suffix = params?.suffix ?: ""
    def checkIn = params?.checkIn ?: false
    
    def action = checkIn ? "checkIn" : "checkOut"

    log.trace "CheckInOutActions Page, no:$no, suffix:$suffix, checkIn:$checkIn, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name: "checkInOutActionsPage", title: "Setup Check ${checkIn ? "In" : "Out"} Actions for ${settings."propertyName${suffix}" ?: "Unit ${no}"}", uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section () {
            input "${action}EnableActions${no}", "bool", title: "Run Check${checkIn ? "-in" : "-out"} actions", required: false, submitOnChange: true
            if (settings."${action}EnableActions${no}") {
                input "${action}Offset${no}", "number", title: "Run actions these many minutes ${checkIn ? "before Check-in" : "after Check-out"}", description: "...at ${checkIn ? "check-in" : "check-out"} time", required: false, range: "1..${maxOffsetActions}"

                /*input "${action}Adt${no}", "bool", title: checkIn ? "Disarm ADT" : "Arm ADT to Away", required: false, submitOnChange: true
                if (settings."${action}Adt${no}") { // If we have a seleted an ADT option
                    input "adtDevices", "capability.battery", title: "Select ADT panel", multiple: false, required: true // Required if we select ADT
                }*/
                //input "${action}Phrase${no}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: settings."${action}Phrase${no}"
                input "${action}TurnOnSwitchesAfterSunset${no}", "capability.switch", title: "Turn on light(s) after sunset", required: false, multiple: true

                input "${action}HomeMode${no}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: settings."${action}HomeMode${no}"
                input "${action}TurnOnSwitches${no}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                input "${action}TurnOffSwitches${no}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
                
                if (!(settings."${action}SetThermostatsHeating${no}" || settings."${action}SetThermostatsCooling${no}")) {
                    input "${action}SetThermostats${no}", "capability.thermostat", title: "Adjust thermostat(s)", required: false, multiple: true, submitOnChange: true
                }
                if (!(settings."${action}SetThermostats${no}" || settings."${action}SetThermostatsHeating${no}" || settings."${action}SetThermostatsCooling${no}")) {
                    paragraph "** OR **"
                }
                if (!settings."${action}SetThermostats${no}") {
                    input "${action}SetThermostatsHeating${no}", "capability.thermostatHeatingSetpoint", title: "Adjust heating thermostat(s)", required: false, multiple: true, submitOnChange: true
                }
                if (settings."${action}SetThermostats${no}" || settings."${action}SetThermostatsHeating${no}") {
                    input "${action}SetThermostatsHeat${no}", "decimal", title: "...heating setpoint (optional)", range: "0..100", required: false
                }
                if (!settings."${action}SetThermostats${no}") {
                    input "${action}SetThermostatsCooling${no}", "capability.thermostatCoolingSetpoint", title: "Adjust cooling thermostat(s)", required: false, multiple: true, submitOnChange: true
                }
                if (settings."${action}SetThermostats${no}" || settings."${action}SetThermostatsCooling${no}") {
                    input "${action}SetThermostatsCool${no}", "decimal", title: "...cooling setpoint (optional)", range: "0..100", required: false
                }

                paragraph title: "Do NOT run the above actions under any of the following conditions", required: true, ""
                input "${action}ActionsXPeople${no}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
                input "${action}ActionsXMode${no}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
            }
        }
    }
}

def genericURLPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params?.passed) {
        atomicState.params = params // We got something, so save it for a page refresh for submitOnChange
        log.trace "Passed from main page, params $params"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState map $map"
    } else {
        log.error "No params found. Params: $params, saved params: $atomicState.params"
    }
    
    def suffix = params?.suffix ?: ""
    def no = (params?.no ?: 0) as Integer
    log.trace "Custom calendar URL Page, No: $no, Suffix: $suffix"

    state.refreshedData = false // Force a download when we come out of this page due to possible configuration changes
    
    dynamicPage(name:"genericURLPage", title: "Property ${no} iCalendar configuration", uninstall: false, install: false) {
        section () {
            href(name: "iCalHelp", title: " ", description: "Enter your channel managers iCal URL below. Click here for details about importing reservation data from custom iCalendars", style: "external", url: "http://www.rboyapps.com/RLA-CustomCals.htm", required: false, image: "https://www.rboyapps.com/images/FAQ.png")
            input "iCalURLGeneric${suffix}", "text", title: "iCalendar URL", description: "Reservation calendar URL for property", required: false, submitOnChange: false, image: "https://www.rboyapps.com/images/GenericReservation.png"
        }
        section () {
            paragraph "By default the user code start/end times for all reservations are taken from the check in/check out time set in the 'Manage Property' page. Enabling this option lets each reservation use its own start/end times."
            input "iCalGeneric${suffix}UseTime", "bool", title: "...use reservation start/end time", description: "Make sure each reservation has a valid start/end time", required: false, submitOnChange: true
            if (settings."iCalGeneric${suffix}UseTime") {
                paragraph "(Optional) Set user code to activate/deactivate before/after scheduled times"
                input "iCalGeneric${suffix}StartOffset", "enum", title: "...activate code before start time", options: genericCalendarTimeOffsets, required: false, submitOnChange: false
                input "iCalGeneric${suffix}EndOffset", "enum", title: "...deactivate code after end time", options: genericCalendarTimeOffsets, required: false, submitOnChange: false
            }
        }
        section () {
            paragraph "By default all calendar events are treated as reservations.\nYou can include or exclude events based on specific words below:"
            input "iCalGeneric${suffix}ExlSummary", "text", title: "...exclude if title starts with", description: "e.g. blocked", required: false, submitOnChange: false, image: "https://www.rboyapps.com/images/Cross.png"
            paragraph title: "OR", ""
            input "iCalGeneric${suffix}IncSummary", "text", title: "...include only if title starts with", description: "e.g. reserved", required: false, submitOnChange: false, image: "https://www.rboyapps.com/images/Check.png"
        }
        section() {
            input "iCalGeneric${suffix}PhonePattern", "bool", title: "Extract phone no. from reservation", description: "Enable if your iCalendar reservation has a phone number that you want to use to generate automatic user codes", required: false, submitOnChange: true
            if (settings."iCalGeneric${suffix}PhonePattern") {
                href(name: "phoneHelp", title: "How to extract phone numbers from iCalendar", description: "Frequently asked questions", style: "external", url: "http://www.rboyapps.com/RLA-CustomCals.htm", required: false, image: "https://www.rboyapps.com/images/FAQ.png")
                paragraph "RLA can extract a phone number from the `DESCRIPTION` field in the reservation iCal file (from the iCalendar URL entered above). While extracting it, RLA will consider the phone number as all digits between the beginning and end markers specified below. All non-digit characters between the beginning and end markers will be ignored.\n► If no end marker is specified, it will take all digits after the beginning marker.\n► If no beginning or end marker is specified, it will take all the digits as the phone number.\n\nNOTE: Refer to the FAQ link above to see how to find the markers in your reservation iCalendar before entering them here.\n\nDon't forget to select 'Using phone number' in the 'automatic code generation` option under `Custom calendar` on the 'Manage Property' page"
                paragraph title: "The phone number lies between", ""
                input "iCalGeneric${suffix}PhonePatternStart", "text", title: "...beginning marker", description: "e.g. phone:", required: false, submitOnChange: false
                paragraph title: "AND", ""
                input "iCalGeneric${suffix}PhonePatternEnd", "text", title: "...end marker", description: "e.g. \\n", required: false, submitOnChange: false

                paragraph "" // Empty line otherwise ST Mobile app doesn't show last input while typing
            }
        }
    }
}

def propertyURLPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params?.passed) {
        atomicState.params = params // We got something, so save it for a page refresh for submitOnChange
        log.trace "Passed from main page, params $params"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState map $map"
    } else {
        log.error "No params found. Params: $params, saved params: $atomicState.params"
    }
    
    def suffix = params?.suffix ?: ""
    def no = (params?.no ?: 0) as Integer
    log.trace "Property URL Page, No: $no, Suffix: $suffix"

    state.refreshedData = false // Force a download when we come out of this page due to possible configuration changes
    
    dynamicPage(name:"propertyURLPage", title: "Property ${no} configuration", uninstall: false, install: false) {
        section ("iCalendar URLs") {
            input "propertyName${suffix}", "text", title: "Property name", description: "", defaultValue: "Unit ${no}", required: true

            if (settings."iCalURLAirBnB${suffix}" && !settings."iCalURLAirBnB${suffix}"?.toLowerCase()?.contains("airbnb")) {
                paragraph title: "Please check your AirBnB iCalendar URL", required: true, ""
            }
            input "iCalURLAirBnB${suffix}", "text", title: "AirBnB", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/AirBnB.png"

            if (settings."iCalURLVRBO${suffix}" && !["vrbo", "homeaway"].any { settings."iCalURLVRBO${suffix}"?.toLowerCase()?.contains(it) }) { // For legacy purposes allow both, HomeAway and Vrbo since they use the same formats
                paragraph title: "Please check your Vrbo iCalendar URL", required: true, ""
            }
            input "iCalURLVRBO${suffix}", "text", title: "Vrbo", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/Vrbo.png"

            if (settings."iCalURLHomeAway${suffix}" && !["vrbo", "homeaway"].any { settings."iCalURLHomeAway${suffix}"?.toLowerCase()?.contains(it) }) { // For legacy purposes allow both, HomeAway and Vrbo since they use the same formats
                paragraph title: "Please check your HomeAway iCalendar URL", required: true, ""
            }
            input "iCalURLHomeAway${suffix}", "text", title: "HomeAway", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/HomeAway.png"

            if (settings."iCalURLBooking${suffix}" && !settings."iCalURLBooking${suffix}"?.toLowerCase()?.contains("booking")) {
                paragraph title: "Please check your Booking.com iCalendar URL", required: true, ""
            }
            input "iCalURLBooking${suffix}", "text", title: "Booking.com", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/Booking.png"

            if (settings."iCalURLTripAdvisor${suffix}" && !settings."iCalURLTripAdvisor${suffix}"?.toLowerCase()?.contains("tripadvisor")) {
                paragraph title: "Please check your TripAdvisor iCalendar URL", required: true, ""
            }
            input "iCalURLTripAdvisor${suffix}", "text", title: "TripAdvisor", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/TripAdvisor.png"

            if (settings."iCalURLExpedia${suffix}" && !settings."iCalURLExpedia${suffix}"?.toLowerCase()?.contains("expedia")) {
                paragraph title: "Please check your Expedia iCalendar URL", required: true, ""
            }
            input "iCalURLExpedia${suffix}", "text", title: "Expedia", description: "Reservation calendar URL for property", required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/Expedia.png"

            def hrefParams = [
                no: no as String, // params has problems with numbers
                suffix: suffix as String, // params has problems with numbers
                passed: true 
            ]
            href(name: "genericURL${suffix}", params: hrefParams, title: "Custom channel managers", page: "genericURLPage", description: settings."iCalURLGeneric${suffix}" ? "Configured" : "Custom iCalendar and channel managers", required: false, image: "https://www.rboyapps.com/images/GenericReservation.png")
        }
        
        // Check in / check out actions
        section ("Actions") {
            def hrefParams = [
                no: no as String, // params has problems with numbers
                suffix: suffix as String, // params has problems with numbers
                passed: true
            ]
            href(name: "checkInActions", params: hrefParams + [checkIn: true], title: "Check in actions", page: "checkInOutActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/CheckIn.png")
            href(name: "checkOutActions", params: hrefParams + [checkIn: false], title: "Check out actions", page: "checkInOutActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/CheckOut.png")
        }
        
        // Locks selection for property
        section ("Property locks (optional)") {
            input "propertyLocks${suffix}", "enum", description: "All locks", title: "Program these lock(s)", options: selectLocks, multiple: true, required: false, image: "https://www.rboyapps.com/images/HandleLock.png"
        }
    }
}

def rentalIntegrationPage() {
    /*if (locks && !state.refreshedData) {
        downloadRentalData() // Start the background download of data if present, give it enough time to finish
        //state.refreshedData = true // We've downloaded - Don't mark as complete here since data may change on this like code length, code type and we may need new download main page
    }*/ // Don't do this here since it triggers too early in initial setup causing errors on this screen about missing code generation
    state.refreshedData = false // Mark as incomplete here after downloading data if required (changes to property URL pages) since data may change on this like code length, code type and we may need new download main page or if this page is reloaded

    dynamicPage(name:"rentalIntegrationPage", title: "Integrate with property management systems to configure automatic management of users", uninstall: false, install: false) {
        if (!locks) {
            section("Invalid locks") {
                paragraph title: "First select the locks on the previous page", required: true, ""
            }
        } else {
            section ("Property/Unit Settings") {
                paragraph "Set the number of units and tap on each unit to configure its calendars and details"
                input name: "rentalUnitsCount", type: "number", title: "How many units?", description: "Many property calendars do you want to configure?", defaultValue: "${defaultRentalUnitsCount}", range: "1..${maxRentalUnitsCount}", required: true, submitOnChange: true
                unitSuffixes.each { no, suffix ->
                        def hrefParams = [
                            no: no as String, // params has problems with numbers
                            suffix: suffix as String, // params has problems with numbers
                            passed: true 
                        ]
                        href(name: "propertyURL${suffix}", params: hrefParams, title: (settings."propertyName${suffix}" ?: "Unit ${no}"), page: "propertyURLPage", description: (settings."iCalURLAirBnB${suffix}" || settings."iCalURLVRBO${suffix}" || settings."iCalURLHomeAway${suffix}" || settings."iCalURLBooking${suffix}" || settings."iCalURLTripAdvisor${suffix}" || settings."iCalURLExpedia${suffix}" || settings."iCalURLGeneric${suffix}") ? ""  : "Tap to configure!", required: false, image: "https://www.rboyapps.com/images/MultiUnitProperty.png")
                }
            }
            
            section ("Scheduling") {
                input name: "rentalPreArrivalActivationDays", type: "number", title: "Days before arrival to activate automatic codes\n(0 to activate on check-in day)", description: "Activate the automatic codes these many days ahead of arrival", defaultValue: "${defaultPreArrivalDays}", range: "0..${maxPreArrivalDays}", required: true
                if (!checkOutTime || !checkInTime) {
                	paragraph title: "SET CHECK-IN & CHECK-OUT TIME", required: true, "Set the check-in and check-out time used to program and delete automatically generated user codes"
                }
                input name: "checkInTime", type: "time", title: "Check-in time to enable code", description: "Required - Activated the code on the lock at this time", required: unitSuffixes.any { no, suffix -> (settings."iCalURLGeneric${suffix}" || settings."iCalURLExpedia${suffix}" || settings."iCalURLTripAdvisor${suffix}" || settings."iCalURLBooking${suffix}" || settings."iCalURLHomeAway${suffix}" || settings."iCalURLVRBO${suffix}" || settings."iCalURLAirBnB${suffix}")} ? true : false
                input name: "checkOutTime", type: "time", title: "Check-out time to disable code", description: "Required - Remove the code from the lock at this time", required: unitSuffixes.any { no, suffix -> (settings."iCalURLGeneric${suffix}" || settings."iCalURLExpedia${suffix}" || settings."iCalURLTripAdvisor${suffix}" || settings."iCalURLBooking${suffix}" || settings."iCalURLHomeAway${suffix}" || settings."iCalURLVRBO${suffix}" || settings."iCalURLAirBnB${suffix}")} ? true : false
            }

            section ("Options and Notifications") {
                // Check if the lock pin code length match on all the locks
                def pinDetails = getLockPinLengthDetails()
                def pinLen = pinDetails.pinLen // Fixed pin code length
                def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
                def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
                def pinLenError = pinDetails.pinLenError
                log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"

                if (pinLenError) { // If we have a pin length mis-match between locks
                    def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING MAY FAIL!"
                    paragraph title: msg, required: true, ""
                } else if (!pinLen) { // If we don't have a pin length that can be determined, then prompt user for one to use
                    paragraph "Enter the number of digits (X) your locks are configured to accept"
                    if (minPinLen && maxPinLen) {
                        def minPin = Math.max(minPinLen as Integer, minAutoPinLen) // We need atleast 4 digits
                        def maxPin = Math.min(maxPinLen as Integer, maxAutoPinLen) // We cannot do more than 8
                        input name: "rentalCodeLength", type: "number", title: "User code length (digits)", description: "Number of digits in user code", defaultValue: "${minPin}", range: "${minPin}..${maxPin}", required: true, submitOnChange: true
                    } else {
                        input name: "rentalCodeLength", type: "number", title: "User code length (digits)", description: "Number of digits in user code", defaultValue: "${minAutoPinLen}", range: "${minAutoPinLen}..${maxAutoPinLen}", required: true, submitOnChange: true
                    }
                }
                
                def codeLen = finalPinLength(pinDetails)
                if (unitSuffixes.any { no, suffix -> settings."iCalURLAirBnB${suffix}"}) {
                    paragraph ""
                    paragraph title: "AirBnB", getAutomaticCodeOptionsAirBnB(codeLen, 4)[settings."autoCodeAirBnB"]?.description // Airbnb only provide the last 4 digits of the phone number now
                    input "autoCodeAirBnB", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsAirBnB(codeLen, 4).collectEntries { k, v -> v.option }, submitOnChange: true
                    // Disable SMS for now since ST doesn't support international SMS and Airbnb only provides last 4 digits now
                    /*if (sendCodeToPhone && !sendCodeToPhone.contains("<code>")) {
                        paragraph "missing <code> in template", title: "INVALID SMS TEMPLATE", required: true
                    }
                    input name: "sendCodeToPhone", type: "text", title: "...send SMS to users phone\n(leave emtpy to disable)", description: "enter text message to send to user", capitalization: "sentences", required: false, submitOnChange: true
                    paragraph "E.g.: Your lock code at <property> is <code> and is valid from <start> to <end>\n\nRLA will substitute the following in your message above:\n<code> for user code\n<start> for start date\n<end> for end date\n<property> for property name"
                    if (sendCodeToPhone) {
                        input name: "sendCodeToPhoneDays", type: "number", title: "...these many days before arrival", description: "send code X days before check-in", required: sendCodeToPhone ? true : false, range: "${minSendCodeToPhoneDays}..*"
                    }*/
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLVRBO${suffix}"}) {
                    paragraph ""
                    paragraph title: "Vrbo", getAutomaticCodeOptionsVRBO(codeLen)[settings."autoCodeVRBO"]?.description
                    input "autoCodeVRBO", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsVRBO(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLHomeAway${suffix}"}) {
                    paragraph ""
                    paragraph title: "HomeAway", getAutomaticCodeOptionsHomeAway(codeLen)[settings."autoCodeHomeAway"]?.description
                    input "autoCodeHomeAway", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsHomeAway(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLBooking${suffix}"}) {
                    paragraph ""
                    paragraph title: "Booking.com", getAutomaticCodeOptionsBooking(codeLen)[settings."autoCodeBooking"]?.description
                    input "autoCodeBooking", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsBooking(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLTripAdvisor${suffix}"}) {
                    paragraph ""
                    paragraph title: "TripAdvisor", getAutomaticCodeOptionsTripAdvisor(codeLen)[settings."autoCodeTripAdvisor"]?.description
                    input "autoCodeTripAdvisor", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsTripAdvisor(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLExpedia${suffix}"}) {
                    paragraph ""
                    paragraph title: "Expedia", getAutomaticCodeOptionsExpedia(codeLen)[settings."autoCodeExpedia"]?.description
                    input "autoCodeExpedia", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsExpedia(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                if (unitSuffixes.any { no, suffix -> settings."iCalURLGeneric${suffix}"}) {
                    paragraph title: "Custom calendar", getAutomaticCodeOptionsGeneric(codeLen)[settings."autoCodeGeneric"]?.description
                    if (autoCodeGeneric == "phone") {
                        href(name: "phoneHelp", title: "NOTE: Please make sure that EVERY reservation 'DESCRIPTION' entry in the iCalendar has the user phone no. as described in this FAQ link", description: "Frequently asked questions", style: "external", url: "http://www.rboyapps.com/RLA-CustomCals.htm", required: false, image: "https://www.rboyapps.com/images/FAQ.png")
                    }
                    input "autoCodeGeneric", "enum", title: "...automatic code generation", required: true, options: getAutomaticCodeOptionsGeneric(codeLen).collectEntries { k, v -> v.option }, submitOnChange: true
                }
                
                paragraph ""
                input name: "rentalUserNotify", type: "bool", title: "Notify when automatic codes are used", defaultValue: true, required: false, submitOnChange: true
                if (rentalUserNotify != false) {
                    input "rentalUserNotifyCount", "number", title: "...limit to only this many times", description: "no limit", required: false, range: "1..*"
                }

                paragraph ""
                input name: "rentalProgrammingNotifications", type: "bool", title: "Get automatic code scheduling notifications", defaultValue: true, required: false, submitOnChange: true

                if (sendCodeToPhone || rentalProgrammingNotifications) {
                    paragraph ""
                    paragraph "Send${sendCodeToPhone ? " SMS" : ""}${rentalProgrammingNotifications != false ? "${sendCodeToPhone ? " and" : ""} automatic code scheduling notifications" : ""} (${new Date(now()).format("z", getTimeZone())})", title: "Notification restrictions"
                    input name: "rentalProgrammingNotificationsStart", type: "time", title: "...from", description: "send anytime", required: false
                    input name: "rentalProgrammingNotificationsEnd", type: "time", title: "...to", description: "send anytime", required: false
                }
            }
        }
    }
}

def openCloseDoorPageSummary() {
    if (locks?.size() > 1) {
        dynamicPage(name:"openCloseDoorPageSummary", title: "Select door open/close sensor and configure the automatic unlock, relock and notifications for each door", uninstall: false, install: false) {
            section {
                for (lock in locks) {
                    def hrefParams = [
                        lockId: lock.id, 
                        passed: true 
                    ]
                    href(name: "openCloseDoor${lock}", params: hrefParams, title: "${lock}", page: "openCloseDoorPage", description: doorOpenCloseStatus(lock), required: false, image: "https://www.rboyapps.com/images/DoorOpenClose.png")
                }
            }
        }
    } else if(locks?.size() == 1) {
        def hrefParams = [
            lockId: locks.first().id, 
            passed: true 
        ]
        openCloseDoorPage(hrefParams)
    } else {
        dynamicPage(name:"openCloseDoorPageSummary", title: "Select door open/close sensor and configure the automatic unlock, relock and notifications for each door", uninstall: false, install: false) {
            section("No locks/doors to configure") {
                paragraph title: "First select locks on the previous page", required: true, ""
            }
        }
    }
}

private doorOpenCloseStatus(lock) { 
    (
        ((lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) ? false : (settings."relockDoor${lock}" ? (settings."relockImmediate${lock}" ?: settings."relockAfter${lock}") : false)) ||
        (settings."openNotifyBeep${lock}" && settings."sensor${lock}") ||
        (settings."openNotify${lock}" && settings."sensor${lock}" && settings."openNotifyTimeout${lock}")
    ) ? "Configured" : ""
}

def openCloseDoorPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no details found. Params: $params, saved params: $atomicState.params"
    }
    
    def lock = params?.lockId ? locks.find { it.id == params?.lockId } : locks.first()

    log.trace "Door Open Close Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"openCloseDoorPage", title: "Door open/close actions for ${lock}", uninstall: false, install: false) {
        section {
            def priorRelockDoor = settings."relockDoor${lock}"
            def priorRelockImmediate = settings."relockImmediate${lock}"
            def priorRelockAfter = settings."relockAfter${lock}"
            def priorRetractDeadbolt = false //settings."retractDeadbolt${lock}"
            def priorNotifyOpen = settings."openNotify${lock}"
            def priorNotifyOpenTimeout = settings."openNotifyTimeout${lock}"
            def priorOpenNotifyModes = settings."openNotifyModes${lock}"
            def priorRelockDoorModes = settings."relockDoorModes${lock}"
            def priorNotifyBeep = settings."openNotifyBeep${lock}"
            def priorSensor = settings."sensor${lock}"
            def reqDoorSensor = priorRelockImmediate || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep

            paragraph "Select door open/close sensor and configure the automatic unlock, relock and notifications"
            if (priorRelockDoor || priorRetractDeadbolt || priorNotifyOpen || priorNotifyBeep) {
                input "sensor${lock}", "capability.contactSensor", title: "Door open/close sensor${reqDoorSensor ? "" : " (optional)"}", required: ( reqDoorSensor ? true : false), submitOnChange: true // required for deadbolt, immediate relock or notifications
            }

            // Sanity check do not offer AutoLock is hardware autoLock is engaged
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                paragraph title: "Disable AutoLock on physical lock to use SmartApp AutoReLock features", required: true, ""
            } else {
                input "relockDoor${lock}", "bool", title: "Relock door automatically", defaultValue: priorRelockDoor, required: false, submitOnChange: true
                if (priorRelockDoor) {
                    input "relockImmediate${lock}", "bool", title: "Relock immediately after closing", defaultValue: priorRelockImmediate, required: false, submitOnChange: true
                    if (!priorRelockImmediate) {
                        input "relockAfter${lock}", "number", title: "Relock after ${priorSensor ? "closing" : "unlocking"} (minutes)", defaultValue: priorRelockAfter, required: true                   
                    }
                    input "relockDoorModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorRelockDoorModes, required: false, multiple: true
                }
                if (priorRetractDeadbolt) {
                    paragraph "NOTE: Make sure the AutoLock feature on the lock is disabled to avoid an infinite locking/unlocking loop.", required: false, submitOnChange: true
                }
                //input "retractDeadbolt${lock}", "bool", title: "Unlock door if locked while open", defaultValue: priorRetractDeadbolt, description: "This retracts the deadbolt if it extends while the door is still open", required: false, submitOnChange: true
            }

            input "openNotifyBeep${lock}", "capability.tone", title: "Ring chime when door is opened", multiple: true, required: false, submitOnChange: true
            input "openNotify${lock}", "bool", title: "Notify if door has been left open", defaultValue: priorNotifyOpen, required: false, submitOnChange: true
            if (priorNotifyOpen) {
                input "openNotifyTimeout${lock}", "number", title: "...for (minutes)", defaultValue: priorNotifyOpenTimeout, required: true, range: "1..*"
                input "openNotifyRepeat${lock}", "bool", title: "...recheck and notify", defaultValue: true, required: false
            }
            if (priorNotifyOpen || priorNotifyBeep) {
                input "openNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", defaultValue: priorOpenNotifyModes, required: false, multiple: true
            }
        }
    }
}

def unlockLockActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Lock/Unlock Action Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockLockActionsPage", title: (user ? "Setup custom actions/notifications for ${name ?: "user ${user}"}" : "Setup lock/unlock actions for each door"), uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/
        def showActions = true
        section {
            if (user) { // User specific override options
                paragraph "Enabling custom user actions and notifications will override over the general actions defined on the first page"
                input "userOverrideUnlockActions${user}", "bool", title: "Define custom actions for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideUnlockActions${user}") { // Check if user has enabled specific override actions then show menu
                    showActions = false
                }
            }
            if  (showActions && locks?.size() > 1) {
                input "individualDoorActions${user}", "bool", title: "Separate actions for each door", required: true,  submitOnChange: true
            }
        }
        if (showActions) { // Do we need to show actions?
            if (settings."individualDoorActions${user}") {
                for (lock in locks) {
                    section ("$lock", hideable: false) {
                        def hrefParams = [
                            user: user,
                            lock: lock as String,
                            passed: true 
                        ]
                        href(name: "unlockKeypadActions${lock}", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/KeypadUnlocked.png")
                        href(name: "lockKeypadActions${lock}", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/KeypadLocked.png")
                        if (!user) {
                            href(name: "unlockManualActions${lock}", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/ManualUnlocked.png")
                            href(name: "lockManualActions${lock}", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/ManualLocked.png")
                        }
                    }
                }
            } else {
                section("", hideable: false) {
                    def hrefParams = [
                        user: user,
                        lock: "",
                        passed: true 
                    ]
                    href(name: "unlockKeypadActions", params: hrefParams, title: "Keypad Unlock Actions", page: "unlockKeypadActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/KeypadUnlocked.png")
                    href(name: "lockKeypadActions", params: hrefParams, title: "Keypad Lock Actions", page: "lockKeypadActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/KeypadLocked.png")
                    if (!user) {
                        href(name: "unlockManualActions", params: hrefParams, title: "Manual Unlock Actions", page: "unlockManualActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/ManualUnlocked.png")
                        href(name: "lockManualActions", params: hrefParams, title: "Manual Lock Actions", page: "lockManualActionsPage", description: "", required: false, image: "https://www.rboyapps.com/images/ManualLocked.png")
                    }
                }
            }
        }
        section {
            if (user && (settings."userNotify${user}" ? settings."userNotify${user}".toBoolean() : settings."userNotify${user}")) { // User specific override notification options
                def showCustomNotifications = true
                input "userOverrideNotifications${user}", "bool", title: "Define custom notifications for ${name ?: "user ${user}"}", required: true,  submitOnChange: true
                if (!settings."userOverrideNotifications${user}") { // Check if user has enabled specific override actions then show menu
                    showCustomNotifications = false
                }
                if (showCustomNotifications) {
                    def hrefParams = [
                        user: user, 
                        passed: true 
                    ]
                    href(name: "notifications", params: hrefParams, title: "Notifications", page: "notificationsPage", description: "", required: false, image: "https://www.rboyapps.com/images/NotificationsD.png")
                }
            }
        }
    }
}

def unlockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Unlock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockKeypadActionsPage", title: "Setup keypad unlock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section ("Door Keypad Unlock Actions${lock ? " for $lock" : ""}") {
            //def priorHomePhrase = settings."homePhrase${lock}${user}"
            def priorHomeMode = settings."homeMode${lock}${user}"
            def isLockKeypad = locks?.find{ it.displayName == lock }?.hasAttribute("armMode") // Check if the current lock (lock specific option) is a keypad
            def isAnyLockKeypad = locks?.any { keypad -> keypad.hasAttribute("armMode") } // Check if any lock (for global options) is a keypad
            def areAllLockKeypad = locks?.every { keypad -> keypad.hasAttribute("armMode") } // Check every lock (for global options) is a keypad
            
            paragraph "Run these actions when a user successfully unlocks the door using a code"
            /*if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control ADT using keypad", required: false, submitOnChange: true, defaultValue: false
            }
            if (lock ? (isLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true) : (areAllLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true)) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                //input "homeDisarm${lock}${user}", "bool", title: "Disarm Classic SHM", required: false
                input "adtDisarm${lock}${user}", "bool", title: "Disarm ADT", required: false, submitOnChange: true
            }
            if (((lock ? (isLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true) : (areAllLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true)) && settings."adtDisarm${lock}${user}") ||
                ((lock ? isLockKeypad : isAnyLockKeypad) && (settings."keypadArmDisarm${lock}${user}"))) { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel${true || settings."adtDisarm${lock}${user}" ? "" : " (optional)"}", multiple: false, required: (true || settings."adtDisarm${lock}${user}" ? true : false) // Required if we select ADT
            }*/
            //input "homePhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "turnOnSwitchesAfterSunset${lock}${user}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "toggleSwitches${lock}${user}", "capability.switch", title: "Toggle switch(s)", required: false, multiple: true
            input "unlockLocks${lock}${user}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarage${lock}${user}","capability.doorControl", title: "Open garage door(s)", required: false, multiple: true

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true
        }
    }
}

def unlockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "Manual Unlock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"unlockManualActionsPage", title: "Setup manual unlock actions for doors", uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section ("Door Manual Unlock Actions${lock ? " for $lock" : ""}") {
            //def priorHomePhrase = settings."homePhraseManual${lock}"
            def priorHomeMode = settings."homeModeManual${lock}"
            def priorManualNotify = settings."manualNotify${lock}"

            paragraph "Run these actions when a user unlocks the door manually"
            //input "homeDisarmManual${lock}", "bool", title: "Disarm Classic SHM", required: false
            /*input "adtDisarmManual${lock}", "bool", title: "Disarm ADT", required: false, submitOnChange: true
            if (settings."adtDisarmManual${lock}") { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel", multiple: false, required: true // Required if we select ADT
            }*/
            //input "homePhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorHomePhrase
            input "homeModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "turnOnSwitchesAfterSunsetManual${lock}", "capability.switch", title: "Turn on light(s) after dark", required: false, multiple: true
            input "turnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "turnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "unlockLocksManual${lock}","capability.lock", title: "Unlock lock(s)", required: false, multiple: true
            input "openGarageManual${lock}","capability.doorControl", title: "Open garage door(s)", required: false, multiple: true

            paragraph title: "Do NOT run the above unlock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleUnlockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeUnlockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Unlock Notification Options"
            input "manualNotify${lock}", "bool", title: "Notify on manual unlock", required: false, submitOnChange: true
            if (priorManualNotify) {
                input "manualNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def armKeypadActionsPage(params) {
    // params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
        log.trace "Passed from main page, using params lookup ${params}"
    } else if (atomicState.params) {
        params = atomicState.params
        log.trace "Passed from submitOnChange, atomicState lookup ${atomicState.params}"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def user = params?.user ?: ""
    def lock = params?.lock ?: ""
    def arm = params?.arm ?: ""

    def name = user ? settings."userNames${user}" : ""

    log.trace "Arm Keypad Action Page, user:$user, name:$name, lock $lock, arm $arm, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"armKeypadActionsPage", title: "Setup Arm ${arm?.capitalize()} button actions for ${lock ?: "keypad"}" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section {
            input "keypadArmActions${lock}${user}${arm}", "bool", title: "Enable custom actions", required: false, submitOnChange: true
            if (settings."keypadArmActions${lock}${user}${arm}") {
                //def priorLockPhrase = settings."externalLockPhrase${lock}${user}${arm}"
                def priorHomeMode = settings."externalLockMode${lock}${user}${arm}"

                //input "externalLockPhrase${lock}${user}${arm}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
                input "externalLockMode${lock}${user}${arm}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
                input "externalLockTurnOnSwitches${lock}${user}${arm}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
                input "externalLockTurnOffSwitches${lock}${user}${arm}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
                input "externalLockToggleSwitches${lock}${user}${arm}", "capability.switch", title: "Toggle switch(s)", required: false, multiple: true
                input "lockLocks${lock}${user}${arm}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
                input "closeGarage${lock}${user}${arm}","capability.doorControl", title: "Close garage door(s)", required: false, multiple: true
            }
        }
    }
}

def lockKeypadActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        user = params.user ?: ""
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for user $user, lock $lock"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user, lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    log.trace "Keypad Lock Action Page, user:$user, name:$name, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockKeypadActionsPage", title: "Setup keypad lock actions for doors" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section ("Door Keypad Lock Actions${lock ? " for $lock" : ""}") {
            //def priorLockPhrase = settings."externalLockPhrase${lock}${user}"
            def priorHomeMode = settings."externalLockMode${lock}${user}"
            def isLockKeypad = locks?.find{ it.displayName == lock }?.hasAttribute("armMode") // Check if the current lock (lock specific option) is a keypad
            def isAnyLockKeypad = locks?.any { keypad -> keypad.hasAttribute("armMode") } // Check if any lock (for global options) is a keypad
            def areAllLockKeypad = locks?.every { keypad -> keypad.hasAttribute("armMode") } // Check every lock (for global options) is a keypad
            
            paragraph "Some locks can be locked from the keypad outside${user ? " with user codes" : ""}. If your lock has his feature then you can assign actions to execute when it is locked ${user ? "with a user code" : "from the keypad"}"
            /*if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                input "keypadArmDisarm${lock}${user}", "bool", title: "Control ADT using keypad", required: false, submitOnChange: true, defaultValue: false
            }
            if (lock ? (isLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true) : (areAllLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true)) { // Hide only if we have have a supported keypad for selected lock and using keypad to control SHM
                //input "homeArm${lock}${user}", "bool", title: "Arm Classic SHM to Away", required: false, submitOnChange: true
                input "adtArm${lock}${user}", "bool", title: "Arm ADT to Away", required: false, submitOnChange: true
                if (settings."adtArm${lock}${user}") {// || settings."homeArm${lock}${user}"
                    input "homeArmStay${lock}${user}", "bool", title: "...arm to Stay instead of Away", required: false
                }
            }
            if (((lock ? (isLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true) : (areAllLockKeypad ? !(settings."keypadArmDisarm${lock}${user}") : true)) && settings."adtArm${lock}${user}") ||
                ((lock ? isLockKeypad : isAnyLockKeypad) && (settings."keypadArmDisarm${lock}${user}"))) { // If we have a seleted an ADT option
                input "adtDevices", "capability.battery", title: "Select ADT panel${true || settings."adtArm${lock}${user}" ? "" : " (optional)"}", multiple: false, required: (true || settings."adtArm${lock}${user}" ? true : false) // Required if we select ADT
            }*/
            if (lock ? isLockKeypad : isAnyLockKeypad) { // Show only if we have a supported keypad (for selected lock or for general settings)
                def hrefParams = [
                    user: user,
                    lock: lock as String,
                    passed: true 
                ]
                href(name: "armAwayKeypadActions${lock}", params: hrefParams + [arm: "away"], title: "Away/On button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
                href(name: "armStayKeypadActions${lock}", params: hrefParams + [arm: "stay"], title: "Stay/Partial button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
                href(name: "armNightKeypadActions${lock}", params: hrefParams + [arm: "night"], title: "Night button actions", page: "armKeypadActionsPage", description: "", required: false, image: "")
            }
            //input "externalLockPhrase${lock}${user}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockMode${lock}${user}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "externalLockTurnOnSwitches${lock}${user}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitches${lock}${user}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "externalLockToggleSwitches${lock}${user}", "capability.switch", title: "Toggle switch(s)", required: false, multiple: true
            input "lockLocks${lock}${user}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarage${lock}${user}","capability.doorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActionsTime${lock}${user}", "number", title: "Delay running actions (minutes)", required: false, range: "0..*"

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActions${lock}${user}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActions${lock}${user}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            if (!user) { // Users will use the user notify option
                paragraph "Lock Notification Options"
                input "externalLockNotify${lock}", "bool", title: "Notify on keypad lock", required: false, submitOnChange: true
                if (settings."externalLockNotify${lock}") {
                    input "externalLockNotifyModes${lock}", "mode", title: "Only when in this mode(s) (optional)", required: false, multiple: true
                }
                input "jamNotify${lock}", "bool", title: "Notify on Lock Jam/Stuck", required: false
            }
        }
    }
}

def lockManualActionsPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def lock = ""
    // Get details from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.passed) {
        lock = params.lock ?: ""
        log.trace "Passed from main page, using params lookup for lock $lock"
    } else if (atomicState.params) {
        lock = atomicState.params.lock ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for lock $lock"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    log.trace "Manual Lock Action Page, lock $lock, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"lockManualActionsPage", title: "Setup manual lock actions for doors", uninstall: false, install: false) {
        /*def phrases = location.helloHome?.getPhrases()
        phrases = phrases ? phrases*.label?.sort() - null : [] // Check for null ghost routines*/

        section ("Door Manual Lock Actions${lock ? " for $lock" : ""}") {
            //def priorLockPhrase = settings."externalLockPhraseManual${lock}"
            def priorHomeMode = settings."externalLockModeManual${lock}"

            //input "homeArmManual${lock}", "bool", title: "Arm Classic SHM to Stay", required: false
            /*input "adtArmManual${lock}", "bool", title: "Arm ADT to Stay", required: false, submitOnChange: true
            if (settings."adtArmManual${lock}") { // If we have a seleted an ADT option
                input "homeArmAwayManual${lock}", "bool", title: "...arm to Away instead of Stay", required: false
                input "adtDevices", "capability.battery", title: "Select ADT panel", multiple: false, required: true // Required if we select ADT
            }*/
            //input "externalLockPhraseManual${lock}", "enum", title: "Run routine", required: false, options: phrases, defaultValue: priorLockPhrase
            input "externalLockModeManual${lock}", "mode", title: "Change mode to", required: false, multiple: false, defaultValue: priorHomeMode
            input "externalLockTurnOnSwitchesManual${lock}", "capability.switch", title: "Turn on switch(s)", required: false, multiple: true
            input "externalLockTurnOffSwitchesManual${lock}", "capability.switch", title: "Turn off switch(s)", required: false, multiple: true
            input "lockLocksManual${lock}","capability.lock", title: "Lock lock(s)", required: false, multiple: true
            input "closeGarageManual${lock}","capability.doorControl", title: "Close garage door(s)", required: false, multiple: true

            input "delayLockActionsTimeManual${lock}", "number", title: "Delay running actions (minutes)", required: false, range: "0..*"

            paragraph title: "Do NOT run the above lock actions for door${lock ? " $lock" : ""} under any of the following conditions", required: true, ""
            input "runXPeopleLockActionsManual${lock}", "capability.presenceSensor", title: "...when any these people are present", required: false, multiple: true
            input "runXModeLockActionsManual${lock}", "mode", title: "...when in any of these mode(s)", required: false, multiple: true

            paragraph "Lock Notification Options"
            input "lockNotify${lock}", "bool", title: "Notify on manual/auto lock", required: false, submitOnChange: true
            if (settings."lockNotify${lock}") {
                input "lockNotifyModes${lock}", "mode", title: "...only when in this mode(s) (optional)", required: false, multiple: true
            }
        }
    }
}

def usersPage() {
    dynamicPage(name:"usersPage", title: "User Names, Codes and Notification Setup", uninstall: false, install: false, refreshInterval: 60) {
        if (!locks) {
            section("Invalid locks") {
                paragraph title: "First select the locks on the previous page", required: true, ""
            }
        } else {
            if (!maxUserNames) {
                section("Invalid number of users") {
                    paragraph title: "First configure the number of users on the previous page", required: true, ""
                }
            } else {
                // Check if the lock pin code length match on all the locks
                def pinDetails = getLockPinLengthDetails()
                def pinLen = pinDetails.pinLen // Fixed pin code length
                def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
                def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
                def pinLenError = pinDetails.pinLenError
                log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"

                // Initialize rental users
                if (!pinLenError) { // Don't setup the codes if there is an error since it may not update again
                    processRentalUsers() // Lets get and setup the rental user information
                }
            }

            TimeZone timeZone = location.timeZone
            if (!timeZone) {
                timeZone = TimeZone.getDefault()
                def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
                log.error msg
                sendPush msg
                section("INVALID HUB LOCATION") {
                    paragraph title: msg, required: true, ""
                }
            }

            def entries = (rentalUnitsCount > 1) ? unitSuffixes.collectMany { no, suffix -> // Keep a local copy of all entries to speed up processing
                (atomicState."unit${no}Airbnb" ?: []) + (atomicState."unit${no}Vrbo" ?: []) + (atomicState."unit${no}HomeAway" ?: []) + (atomicState."unit${no}Booking" ?: []) + (atomicState."unit${no}TripAdvisor" ?: []) + (atomicState."unit${no}Expedia" ?: []) + (atomicState."unit${no}Generic" ?: [])
            } : [] // We need unit information only if we have more than one unit configured

            section() {
                def manualHeader = false
                def rentalHeader = false
                def manualUsers = getAllManualUsers() // We DON'T sort these by name since if you reduce the number of manual users it will appear to remove users randomly, so maintain slot ordering
                def rentalUsers = getAllRentalUsers()?.sort { (it.startDate ?: "2100-12-31") + (it.startTime ?: "00:00") } // (yyyy-MM-dd) Get a list of All Rental Users, we want earliest startDate entries first and then startTime, no startDate at the end, we dont' need timezone here since we are just sorting with relative to each other and not comparing to current date/time
                def allUserCodes = (manualUsers + rentalUsers).collectEntries { [(it.user):it.code] } // Get all user codes to save db access time
                for (slot in (manualUsers + rentalUsers)) { // Speed up access by using the consolidated list rather than going back to settings
                    def i = slot.user
                    def priorName = slot.name
                    def priorCode = slot.code
                    def priorExpireDate = slot.expDate
                    def priorExpireTime = slot.expTime
                    def priorStartDate = slot.startDate
                    def priorStartTime = slot.startTime
                    def priorUserType = slot.type
                    def priorUserPresent = settings."userPresent${i}" // Get user presence
                    def priorUserNotPresent = settings."userNotPresent${i}" // Get user not presence
                    def priorUserModes = settings."userModes${i}" // Get user modes
                    def userLocks = (locks?.size() > 1) ? (slot.userLocks ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
                    def no = entries.find { it?.name == priorName }?.unit
                    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ? " (${settings."propertyName${unitSuffixes[no]}"})" : " (Unit ${no})") : ""
                    def invalidStartDate = false
                    def invalidExpiryDate = false
                    def userSummary = ""
                    def userSlotActive = true
                    def userSlotProgrammed = false
                    def pendingUpdate = false
                    def failedUpdate = false
                    //log.trace "Initial $i Name: $priorName, Code: $priorCode, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, StartDate: $priorStartDate, StartTime: $priorStartTime, UserType: $priorUserType"

                    if (!manualHeader && maxManualUsers) { // Insert a header
                        paragraph "Manually Configured Users"
                        manualHeader = true // We're done with the header
                    } else if (!rentalHeader && maxRentalUsers && (i >= ((maxManualUsers ?: 0) + 1))) { // Insert a header if we have rental users setup
                        paragraph "" // break
                        paragraph "Automatically Configured Users"
                        rentalHeader = true // We're done with the header
                    }

                    // Check for errors and display messages
                    if (priorCode) { // Do all the checks only if user has been configured
                        // Sanity check, codes cannot be reused in the same lock (codes have to be unique to each slot)
                        if (maxManualUsers && (i <= maxManualUsers)) { // Only applied to manual users, multiple automatic users don't work on the same day so there no conflict if the same users have multiple schedules
                            getDuplicateCodeUsers(allUserCodes, i).each { j ->
                                def msg = "CHANGE CODE - THIS CODE HAS BEEN USED FOR USER $j"
                                log.warn "CHANGE CODE FOR USER $i - THIS CODE HAS BEEN USED FOR USER $j"
                                userSummary += (userSummary ? "\n" : "") + msg
                            }
                        }

                        // Check if the user has entered a non digit string
                        if ((priorCode?.size() > 0) && !priorCode?.isNumber()) {
                            def msg = "WARNING: CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL!"
                            log.warn msg
                            userSummary += (userSummary ? "\n" : "") + msg
                        }

                        // Check if the lock pin code length match the pin code length entered by the user
                        def pinDetails = getLockPinLengthDetails((locks ?: []).findAll { userLocks.contains(it?.id) })
                        def pinLen = pinDetails.pinLen // Fixed pin code length
                        def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
                        def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
                        def pinLenError = pinDetails.pinLenError
                        //log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"
                        for (lock in locks) {
                            if (userLocks?.contains(lock.id) && (pinLen || (maxPinLen && minPinLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                                if ((priorCode?.size() > 0) && (pinLen ? pinLen != priorCode.size() : ((priorCode.size() < minPinLen) || (priorCode.size() > maxPinLen)))) { // If we have a code to program
                                    def msg = "$lock IS CONFIGURED TO ACCEPT ${pinLen ?: "${minPinLen}-${maxPinLen}"} DIGIT CODES ONLY, PROGRAMMING WILL FAIL!"
                                    log.warn msg
                                    userSummary += (userSummary ? "\n" : "") + msg
                                    break // one message is enough
                                }
                            }
                        }

                        // Sanity check for expiration date formats
                        switch (priorUserType) {
                            case 'Expire on':
                                if (priorStartDate) {
                                    //log.trace "Found start date in setup"
                                    try {
                                        if (!(priorStartDate ==~ /^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$/)) { // Check for valid date format (yyyy-MM-dd)
                                            throw new RuntimeException("Invalid date format")
                                        }
                                        def df = Date.parse("yyyy-MM-ddHH:mm", priorStartDate + "00:00") // Test it
                                        invalidStartDate = false
                                    }
                                    catch (Exception e) {
                                        log.warn "Invalid start date for user $i"
                                        invalidStartDate = true
                                    }
                                }
                                if (priorExpireDate) {
                                    //log.trace "Found expiry date in setup"
                                    try {
                                        if (!(priorExpireDate ==~ /^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$/)) { // Check for valid date format (yyyy-MM-dd)
                                            throw new RuntimeException("Invalid date format")
                                        }
                                        def df = Date.parse("yyyy-MM-ddHH:mm", priorExpireDate + "00:00") // Test it
                                        invalidExpiryDate = false // We passed it's a valid date
                                    }
                                    catch (Exception e) {
                                        log.warn "Invalid expiry date for user $i"
                                        invalidExpiryDate = true
                                    }
                                }

                                if (!invalidExpiryDate && !invalidStartDate) {
                                    if (priorExpireDate) {
                                        def expired = false
                                        if (priorExpireTime) {
                                            // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                            def exp = Date.parse("yyyy-MM-ddHH:mmZ", priorExpireDate + timeToday(priorExpireTime, timeZone).format("HH:mmZ", timeZone))
                                            if (exp.getTime() < now()) {
                                                def msg = "Code EXPIRED!"
                                                userSummary += (userSummary ? "\n" : "") + msg
                                                expired = true
                                                userSlotActive = false
                                            } else {
                                                if (priorStartDate && priorStartTime && !expired) {
                                                    def start = Date.parse("yyyy-MM-ddHH:mmZ", priorStartDate + timeToday(priorStartTime, timeZone).format("HH:mmZ", timeZone))
                                                    if (start.getTime() > now()) {                                                
                                                        def msg = "Activates ${start.format("EEE d MMM yy HH:mm", timeZone)}"
                                                        userSummary += (userSummary ? "\n" : "") + msg
                                                        userSlotActive = false
                                                    }
                                                }
                                                def msg = "Expires ${exp.format("EEE d MMM yy HH:mm", timeZone)}"
                                                userSummary += (userSummary ? "\n" : "") + msg
                                            }
                                        }
                                    }
                                } else {
                                    def msg = "INVALID Date!"
                                    userSummary += (userSummary ? "\n" : "") + msg
                                    userSlotActive = false
                                }
                                break

                            case 'One time':
                                if (state.trackUsedOneTimeCodes?.contains(i as String)) {
                                    def msg = "One time code USED!"
                                    userSummary += (userSummary ? "\n" : "") + msg
                                    userSlotActive = false
                                }
                                break

                            case 'Scheduled':
                                if (!(schedulesSuffix.any { schedule -> settings."userDayOfWeek${schedule}${i}" })) { // If no schedules are defined
                                    def msg = "No schedule defined!"
                                    userSummary += (userSummary ? "\n" : "") + msg
                                    userSlotActive = false
                                } else if (!schedulesSuffix.any { schedule -> checkSchedule(i, schedule) }) { // Check if we are outside operating schedule
                                    userSlotActive = false
                                }
                                break

                            case 'Presence':
                                if (!(priorUserPresent || priorUserNotPresent)) { // No conditions is specified
                                    def msg = "No presence defined!"
                                    userSummary += (userSummary ? "\n" : "") + msg
                                    userSlotActive = false
                                } else if (!((priorUserPresent || priorUserNotPresent) && // No condition is true
                                             (priorUserPresent ? priorUserPresent.any{it.currentPresence == "present"} : true) &&
                                             (priorUserNotPresent ? priorUserNotPresent.every{it.currentPresence != "present"} : true)
                                            )) {
                                    userSlotActive = false
                                }
                                break

                            case 'Modes':
                                if (!priorUserModes?.find{it == location.mode}) {
                                    userSlotActive = false
                                }
                                break

                            case 'Inactive':
    	                        userSlotActive = false
        	                    break

                            case 'Permanent':
	                            break

                            default:
                                def msg = "No user type selected!"
                                userSummary += (userSummary ? "\n" : "") + msg
                                userSlotActive = false // if there's no user type, it's deleted
                                break
                        }

                        if (!userSummary) { // If there are no messages or warnings then indicate user type
                            userSummary += priorUserType
                        }
                    } else if (priorName) { // Incomplete configuration
                        def msg = "No code defined!"
                        userSummary += (userSummary ? "\n" : "") + msg
                        userSlotActive = false
                    } else { // Not configured
                        userSlotActive = false
                    }

                    // Check if code has been changed and pending programming by lock
                    for (lock in locks) {
                        if (userLocks?.contains(lock.id)) {
                            if ((state.retryCodeCount != null) && (state.retryCodeCount[lock.id]?.(i as String) > (maxRetries + 1))) { // Failed to update
                                failedUpdate = true
                                break
                            } else if (userSlotActive && (state.lockCodes != null) && (state.lockCodes[lock.id]?.(i as String) != priorCode)) { // Programming pending update
                                pendingUpdate = true
                                break
                            } else if (!userSlotActive && (state.lockCodes != null) && state.lockCodes[lock.id]?.(i as String)) { // Deletion pending update
                                pendingUpdate = true
                                break
                            }
                        } else if ((state.retryCodeCount != null) && (state.retryCodeCount[lock.id]?.(i as String) > (maxRetries + 1))) { // Failed to update from lock not selected
                            failedUpdate = true
                            break
                        } else if ((state.lockCodes != null) && state.lockCodes[lock.id]?.(i as String)) { // Deletion pending update from a lock not selected
                            pendingUpdate = true
                            break
                        }

                        if (!failedUpdate && !pendingUpdate) { // If it isn't failed/pending then it's active or inactive
                            if ((state.lockCodes != null) && state.lockCodes[lock.id]?.(i as String)) { // Still active
                                userSlotProgrammed = true
                            }
                        }
                    }

                    // Params for user
                    def hrefParams = [
                        user: i as String,
                        passed: true 
                    ]
                    href(name: "userConfig${i}", params: hrefParams, title: "${priorName ? (priorName + propertyName) : "< empty >"}", page: "userConfigPage", description: userSummary, required: false, image: (failedUpdate ? "https://www.rboyapps.com/images/UserFailed.png" : (pendingUpdate ? "https://www.rboyapps.com/images/UserPending.png" : (userSlotProgrammed ? "https://www.rboyapps.com/images/User.png" : "https://www.rboyapps.com/images/UserInactive.png"))))
                }
            } 
        } 
    }
}

def userConfigPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user:$user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user:$user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""
    def i = user as Integer

    log.trace "User Codes Page, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"userConfigPage", title: "User Management Slot #${i}", uninstall: false, install: false) {
        TimeZone timeZone = location.timeZone
        if (!timeZone) {
            timeZone = TimeZone.getDefault()
            def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
            log.error msg
            sendPush msg
            section("INVALID HUB LOCATION") {
                paragraph title: msg, required: true, ""
            }
        }

        section() {
            def priorName = settings."userNames${i}"
            def priorCode = settings."userCodes${i}"
            def priorNotify = settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : settings."userNotify${i}" // UpdateSettings stores it as string
            def priorNotifyModes = settings."userNotifyModes${i}"
            def priorExpireDate = settings."userExpireDate${i}"
            def priorExpireTime = settings."userExpireTime${i}"
            def priorStartDate = settings."userStartDate${i}"
            def priorStartTime = settings."userStartTime${i}"
            def priorUserType = settings."userType${i}"
            def priorUserPresent = settings."userPresent${i}" // Get user presence
            def priorUserNotPresent = settings."userNotPresent${i}" // Get user not presence
            def priorUserModes = settings."userModes${i}" // Get user modes
            def userLocks = (locks?.size() > 1) ? (settings."userLocks${i}" ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
            def invalidStartDate = false
            def invalidExpiryDate = false
            def userSlotActive = true
            log.trace "Initial $i Name: $priorName, Code: $priorCode, Notify: $priorNotify, NotifyModes: $priorNotifyModes, ExpireDate: $priorExpireDate, ExpireTime: $priorExpireTime, StartDate: $priorStartDate, StartTime: $priorStartTime, UserType: $priorUserType"

            // Check if the lock pin code length match the pin code length entered by the user
            def pinDetails = getLockPinLengthDetails((locks ?: []).findAll { userLocks.contains(it?.id) })
            def pinLen = pinDetails.pinLen // Fixed pin code length
            def maxPinLen = pinDetails.maxPinLen // Variable minimum pin code length
            def minPinLen = pinDetails.minPinLen // Variable maximum pin code length
            def pinLenError = pinDetails.pinLenError
            log.trace "Configured lock fixed code length: $pinLen, max code length: $maxPinLen, min code length: $minPinLen"

            // Check for errors and display messages
            if (priorCode) { // Do all the checks only if user has been configured
                // Sanity check, codes cannot be reused in the same lock (codes have to be unique to each slot)
                def allUserCodes = (1..(maxUserNames ?: 0)).collectEntries { [(it):settings."userCodes${it}"] } // Get all user codes to save db access time
                getDuplicateCodeUsers(allUserCodes, i).each { j ->
                    if (maxManualUsers && (i <= maxManualUsers)) { // Separate message for manual users
                        log.warn "CHANGE CODE FOR USER $i - THIS CODE HAS BEEN USED FOR USER $j"
                        paragraph title: "CHANGE CODE - THIS CODE HAS BEEN USED FOR USER $j", required: true, ""
                    } else {
                        log.warn "DUPLICATE CODE FOR USER $i AND USER $j, MAY CAUSE PROGRAMMING FAILURE"
                        paragraph title: "Duplicate code with user $j, may cause programming failure", required: false, ""
                    }
                }

                // Check if the user has entered a non digit string
                if ((priorCode?.size() > 0) && !priorCode?.isNumber()) {
                    def msg = "WARNING: CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL!"
                    paragraph title: msg, required: true, ""
                }

                // Check if the lock pin code length match the pin code length entered by the user
                for (lock in locks) {
                    if (userLocks?.contains(lock.id) && (pinLen || (maxPinLen && minPinLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                        if ((priorCode?.size() > 0) && (pinLen ? pinLen != priorCode.size() : ((priorCode.size() < minPinLen) || (priorCode.size() > maxPinLen)))) { // If we have a code to program
                            def msg = "$lock IS CONFIGURED TO ACCEPT ${pinLen ?: "${minPinLen}-${maxPinLen}"} DIGIT CODES ONLY, PROGRAMMING WILL FAIL!"
                            paragraph title: msg, required: true, ""
                            break // one message is enough
                        }
                    }
                }

                // Sanity check for expiration date formats
                switch (priorUserType) {
                    case 'Expire on':
                        if (priorStartDate) {
                            //log.trace "Found start date in setup"
                            try {
                                if (!(priorStartDate ==~ /^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$/)) { // Check for valid date format (yyyy-MM-dd)
                                    throw new RuntimeException("Invalid date format")
                                }
                                def df = Date.parse("yyyy-MM-ddHH:mm", priorStartDate + "00:00") // Test it
                                log.trace "Start:" + df.format("EEE MMM dd yyyy")
                                invalidStartDate = false
                            }
                            catch (Exception e) {
                                log.warn "Invalid start date in setup"
                                invalidStartDate = true
                            }
                        }
                        if (priorExpireDate) {
                            //log.trace "Found expiry date in setup"
                            try {
                                if (!(priorExpireDate ==~ /^\d{4}\-(0[1-9]|1[012])\-(0[1-9]|[12][0-9]|3[01])$/)) { // Check for valid date format (yyyy-MM-dd)
                                    throw new RuntimeException("Invalid date format")
                                }
                                def df = Date.parse("yyyy-MM-ddHH:mm", priorExpireDate + "00:00") // Test it
                                log.trace "Expire:" + df.format("EEE MMM dd yyyy")
                                invalidExpiryDate = false // We passed it's a valid date
                            }
                            catch (Exception e) {
                                log.warn "Invalid expiry date in setup"
                                invalidExpiryDate = true
                            }
                        }

                        if (!invalidExpiryDate && !invalidStartDate) {
                            if (priorExpireDate) {
                                def expired = false
                                if (priorExpireTime) {
                                    // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                    def exp = Date.parse("yyyy-MM-ddHH:mmZ", priorExpireDate + timeToday(priorExpireTime, timeZone).format("HH:mmZ", timeZone))
                                    if (exp.getTime() < now()) {
                                        paragraph title: "Code EXPIRED!", required: true, ""
                                        expired = true
                                        userSlotActive = false
                                    } else {
                                        if (priorStartDate && priorStartTime && !expired) {
                                            def start = Date.parse("yyyy-MM-ddHH:mmZ", priorStartDate + timeToday(priorStartTime, timeZone).format("HH:mmZ", timeZone))
                                            if (start.getTime() > now()) {
                                                def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                                paragraph title: "Code activates on ${startStr}", required: true, ""
                                                userSlotActive = false
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            paragraph title: "INVALID Date!", required: true, ""
                            userSlotActive = false
                        }
                        break

                    case 'One time':
                        if (state.trackUsedOneTimeCodes?.contains(i as String)) {
                            def msg = "One time code USED!"
                            paragraph title: msg, required: true, ""
                            userSlotActive = false
                        }
                        break

                    case 'Scheduled':
                        if (!(schedulesSuffix.any { schedule -> settings."userDayOfWeek${schedule}${i}" })) { // If no schedules are defined
                            def msg = "No schedule defined!"
                            paragraph title: msg, required: true, ""
                            userSlotActive = false
                        } else if (!schedulesSuffix.any { schedule -> checkSchedule(i, schedule) }) { // Check if we are outside operating schedule
                            userSlotActive = false
                        }
                        break

                    case 'Presence':
                        if (!(priorUserPresent || priorUserNotPresent)) { // No conditions is specified
                            def msg = "No presence defined!"
                            paragraph title: msg, required: true, ""
                            userSlotActive = false
                        } else if (!((priorUserPresent || priorUserNotPresent) && // No condition is true
                                     (priorUserPresent ? priorUserPresent.any{it.currentPresence == "present"} : true) &&
                                     (priorUserNotPresent ? priorUserNotPresent.every{it.currentPresence != "present"} : true)
                                    )) {
                            userSlotActive = false
                        }
                        break

                    case 'Modes':
                        if (!priorUserModes?.find{it == location.mode}) {
                            userSlotActive = false
                        }
                        break

                    case 'Inactive':
                        userSlotActive = false
                        break

                    case 'Permanent':
        	            break

                    default:
                        def msg = "No user type selected!"
                        paragraph title: msg, required: true, ""
	                    userSlotActive = false // if there's no user type, it's deleted
    	                break
                }
            } else if (priorName) { // Incomplete configuration
                def msg = "No code defined!"
                paragraph title: msg, required: true, ""
                userSlotActive = false
            } else { // Not configured
                userSlotActive = false
            }

            // Check if code has been changed and pending programming by lock
            for (lock in locks) {
                if (userLocks?.contains(lock.id)) {
                    if ((state.retryCodeCount != null) && (state.retryCodeCount[lock.id]?.(i as String) > (maxRetries + 1))) { // Failed to update
                        def msg = "No response from $lock"
                        paragraph title: msg, required: true, ""
                    } else if (userSlotActive && (state.lockCodes != null) && (state.lockCodes[lock.id]?.(i as String) != priorCode)) { // Programming pending update
                        def msg = "Pending addition confirmation from $lock"
                        paragraph msg
                    } else if (!userSlotActive && (state.lockCodes != null) && state.lockCodes[lock.id]?.(i as String)) { // Deletion pending update
                        def msg = "Pending deletion confirmation from $lock"
                        paragraph msg
                    }
                } else if ((state.retryCodeCount != null) && (state.retryCodeCount[lock.id]?.(i as String) > (maxRetries + 1))) { // Failed to update from lock not selected
                    def msg = "No response from $lock"
                    paragraph title: msg, required: true, ""
                } else if ((state.lockCodes != null) && state.lockCodes[lock.id]?.(i as String)) { // Deletion pending update from a lock not selected
                    def msg = "Pending deletion confirmation from $lock"
                    paragraph msg
                }
            }

            // User and code details/types
            input "userNames${i}", "text", description: "Tap to set", title: "Name", multiple: false, required: (settings."userCodes${i}" ? true : false), submitOnChange: false, image: "https://www.rboyapps.com/images/UserPage.png"
            input "userCodes${i}", "text", description: "Tap to set", title: "Code${pinLen ? " (${pinLen} digits)" : ((minPinLen && maxPinLen) ? " (${minPinLen}-${maxPinLen} digits)" : "")}", multiple: false, required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/Code.png" // Input it type text otherwise users can't enter the number starting with 0

            // Lock selection
            if (locks?.size() > 1) {
                input "userLocks${i}", "enum", description: "All locks", title: "Only on these lock(s)", options: selectLocks, multiple: true, required: false, image: "https://www.rboyapps.com/images/HandleLock.png"
            }

            // User Type (Permanent, One Time, Scheduled, etc)
            input "userType${i}", "enum", title: "Select User Type", required: true, multiple: false, options: codeOptions, defaultValue: 'Permanent', submitOnChange: true, image: "https://www.rboyapps.com/images/Schedule.png"

            // Expiration/Scheduling options
            switch (priorUserType) {
                case 'Expire on':
                    if (invalidStartDate == true) {
                        paragraph title: "INVALID START DATE - PLEASE CHECK YOUR DATE FORMAT", required: true, ""
                    }
                    input "userStartDate${i}", "text", title: "...code start date (YYYY-MM-DD) (optional)", description: "date on which the code should be enabled", required: false,  submitOnChange: true
                    if (priorStartDate) {
                        input "userStartTime${i}", "time", title: "...code start time", description: "the code would be enabled within 2 minutes of this time", required: true,  submitOnChange: false
                    }
                    if (invalidExpiryDate == true) {
                        paragraph title: "INVALID EXPIRY DATE - PLEASE CHECK YOUR DATE FORMAT", required: true, ""
                    }
                    input "userExpireDate${i}", "text", title: "...code expiration date (YYYY-MM-DD)", description: "date on which the code should be deleted", defaultValue: (new Date(now())).format("yyyy-MM-dd", timeZone), required: true, submitOnChange: true
                    input "userExpireTime${i}", "time", title: "...code expiration time", description: "the code would be deleted within 2 minutes of this time", required: true, submitOnChange: false
                    break

                case 'Scheduled':
                    // 3 schedule options for each user
                    schedulesSuffix.each { schedule ->
                        def hrefParams = [
                            user: i as String,
                            schedule: schedule,
                            passed: true
                        ]
                        href(name: "schedule${schedule}", params: hrefParams, title: "...click here to define schedule ${schedule}", page: "scheduleCodesPage", description: getUserScheduleDescription(i, schedule, timeZone), required: false)
                    }
                    break

                case 'Presence':
                    input "userPresent${i}", "capability.presenceSensor", title: "...if any these people are present", description: "code should be active when any of these people are present", required: false, multiple: true
                    input "userNotPresent${i}", "capability.presenceSensor", title: "...and none of these people are present", description: "when all these people are not present", required: false, multiple: true
                    input "userPresenceLock${i}", "bool", title: "...lock automatically", description: "lock doors when deactivating user", required: false
                    input "userPresenceUnlock${i}", "bool", title: "...unlock automatically", description: "unlock doors when activating user", required: false
                    break

                case 'Modes':
                    input "userModes${i}", "mode", title: "...when in this mode(s)", description: "code should be active only during these modes", required: true, multiple: true
                    break

                default:
                    break
            }

            // Notifications for each user
            input "userNotify${i}", "bool", title: "Notify on use", defaultValue: true, required: false, submitOnChange: true, image: "https://www.rboyapps.com/images/Notifications.png"
            if (priorNotify != false) {
                input "userNotifyUseCount${i}", "number", title: "...limit to only this many times", description: "no limit", required: false, range: "1..*"
                input "userNotifyModes${i}", "mode", title: "...only when in this mode(s)", description: "notify only when in any of these modes", required: false, multiple: true
                input "userXNotifyPresence${i}", "capability.presenceSensor", title: "...and none of these people are present", description: "when all these people are not present", required: false, multiple: true
            }

            // Unlock actions for each user
            def hrefParams = [
                user: i as String, 
                passed: true 
            ]
            href(name: "unlockLockActions", params: hrefParams, title: "Custom actions/notifications", page: "unlockLockActionsPage", description: (settings."userOverrideUnlockActions${user}" || (settings."userOverrideNotifications${user}" && (settings."userNotify${user}" ? settings."userNotify${user}".toBoolean() : settings."userNotify${user}"))) ? "Configured" : "", required: false, image: "https://www.rboyapps.com/images/LockUnlock.png")
        }
    }
}

// format: [no:"suffix", ...]
private getUnitSuffixes() {
    return (rentalUnitsCount > 1) ? [ 1:"" ] + (2..rentalUnitsCount).collectEntries { [(it):(it as String)] } : [ 1:"" ] // 1st property URL has no suffix for backward compatibility with v1 of the app
}

// List of booking sources to use identify reservation source (bSource)
private getBookingSources() {
    [
        "AirBnB": "AirBnB",
        "VRBO": "VRBO",
        "HomeAway": "HomeAway",
        "Booking": "Booking",
        "TripAdvisor": "TripAdvisor",
        "Expedia": "Expedia",
        "Generic": "Generic",
    ]
}

private getSelectLocks() {
    return (locks?.collectEntries { [ (it.id) : (it.displayName) ] })?.sort { it.value.toLowerCase() } // Get lock_id:lock_name and sort by name
}

private getUserScheduleDescription(i, schedule, timeZone) {
    def retVal = "Not defined"
    if (settings."userDayOfWeek${schedule}${i}") {
        retVal = ""
        settings."userDayOfWeek${schedule}${i}".each { retVal += (retVal ? ", " : "") + it }// DOW
        retVal += ": " + (settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : "") // Start Time
        retVal += " - " + (settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : "") // EndTime
    }
    return retVal
}

def scheduleCodesPage(params) {
    //  params is broken, after doing a submitOnChange on this page, params is lost. So as a work around when this page is called with params save it to state and if the page is called with no params we know it's the bug and use the last state instead
    if (params.passed) {
        atomicState.params = params // We got something, so save it otherwise it's a page refresh for submitOnChange
    }

    def user = ""
    def schedule = ""
    // Get user from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.user) {
        user = params.user ?: ""
        log.trace "Passed from main page, using params lookup for user $user"
    } else if (atomicState.params) {
        user = atomicState.params.user ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for user $user"
    } else {
        log.error "Invalid params, no user found. Params: $params, saved params: $atomicState.params"
    }
    
    def name = user ? settings."userNames${user}" : ""

    // Get schedule from the passed in params when the page is loading, else get from the last saved to work around not having params on pages
    if (params.schedule) {
        schedule = params.schedule ?: ""
        log.trace "Passed from main page, using params lookup for schedule $schedule"
    } else if (atomicState.params) {
        schedule = atomicState.params.schedule ?: ""
        log.trace "Passed from submitOnChange, atomicState lookup for schedule $schedule"
    } else {
        log.error "Invalid params, no schedule found. Params: $params, saved params: $atomicState.params"
    }

    log.trace "Schedule Codes Page, schedule:$schedule, user:$user, name:$name, passed params: $params, saved params:$atomicState.params"

    dynamicPage(name:"scheduleCodesPage", title: "Define schedule ${schedule}" + (user ? " for user $name." : ""), uninstall: false, install: false) {
        section() {
            def i = user as Integer
            def priorUserDayOfWeek = settings."userDayOfWeek${schedule}${i}"
            def priorUserStartTime = settings."userStartTime${schedule}${i}"
            def priorUserEndTime = settings."userEndTime${schedule}${i}"
            log.trace "Schedule:$schedule, User:$i, Name: $name, UserDayOfWeek: $priorUserDayOfWeek, UserStartTime: $priorUserStartTime, UserEndTime: $priorUserEndTime"

            input "userStartTime${schedule}${i}", "time", title: "Start Time", required: false
            input "userEndTime${schedule}${i}", "time", title: "End Time", required: false
            input "userDayOfWeek${schedule}${i}",
                "enum",
                title: "Which day of the week?",
                description: "Not defined",
                required: false,
                multiple: true,
                options: schedulingOptions
        }
    }
}

// Maximum number of codes supports by the locks (Maximum Common Number)
private getMaxCodes() {
    def maxCommonCodes = 0
    for (lock in locks) {
        def lockMax = (lock.hasAttribute("maxCodes") ? lock.currentValue("maxCodes") : 0) as Integer
        //log.trace "$lock has max users: $lockMax"
        maxCommonCodes = maxCommonCodes ? (lockMax ? Math.min(lockMax, maxCommonCodes) as Integer : maxCommonCodes) : (lockMax ?: 0) // Take the least amongst all selected locks
    }
    
    //log.trace "Max users: $maxCommonCodes"
    return maxCommonCodes
}

// Get the pin length to use to generate user codes
private finalPinLength(pinDetails) {
    !pinDetails.pinLen ? (rentalCodeLength ?: pinDetails.minPinLen) : (pinDetails.pinLen ?: pinDetails.minPinLen)
}

// Check if the lock pin code length match on all the locks
// pinLen - Fixed pin code length
// maxPinLen - Variable minimum pin code length
// minPinLen - Variable maximum pin code length
// pinLenError - true / false
private getLockPinLengthDetails(subLocks = locks) {
    def pinLen = null // Fixed pin code length
    def maxPinLen = null // Variable minimum pin code length
    def minPinLen = null // Variable maximum pin code length
    def pinLenError = false

    for (lock in subLocks) {
        def codeLen = (lock.currentValue("codeLength") ?: (lock.currentValue("pinLength") ?: null)) as Integer
        def maxCodeLen = (lock.currentValue("maxCodeLength") ?: (lock.currentValue("maxPINLength") ?: null)) as Integer
        def minCodeLen = (lock.currentValue("minCodeLength") ?: (lock.currentValue("minPINLength") ?: null)) as Integer
        //log.trace "$lock fixed code length: $codeLen, max code length: $maxCodeLen, min code length: $minCodeLen"
        if (codeLen && pinLen) { // If lock has fixed pin length and previous lock also had fixed pin length
            if ((codeLen != pinLen) || (maxPinLen && (codeLen > maxPinLen)) || (minPinLen && (codeLen < minPinLen))) { // Check if we have pin mismatches
                pinLenError = true // All locks must have the same pinLength
            }
        } else if (codeLen) { // If lock has fixed pin length
            pinLen = codeLen // Save the length for future use
        } else if (minCodeLen && maxCodeLen) { // Check for range validation
            if (!minPinLen || (minCodeLen > minPinLen)) {
                minPinLen = minCodeLen
            }
            if (!maxPinLen || (maxCodeLen < maxPinLen)) {
                maxPinLen = maxCodeLen
            }
        }
    }
    
    return [ pinLen: pinLen, maxPinLen: maxPinLen, minPinLen: minPinLen, pinLenError: pinLenError ]
}

// Check if we have exceed the memory limit of ST's platform
private checkMemoryStatus() {
    def memLimit = 100000F // Sanity check, state/atomicState have a limit of 100K UTF-8 characters
    def memReportingThreshold = 0.95F // Notify user if it's greater than 95% warn the user
    def memUsed = (state.toString()?.length() as Float) // Calculate how much memory we are using
    log.trace "${(memUsed/memLimit*100 as Float).round(1)}% memory used"
    
    if (memUsed > (memLimit * memReportingThreshold)) {
        def msg = "WARNING: TOO MUCH INFORMATION RECEIVED FROM PROPERTIES! CONTACT RBOY APPS, QUOTE ${memUsed} BYTES"
        log.error msg
        sendPush(msg)
    }
    
    return memUsed
}

// Downloads the property management calendars, parses the rental user schedules and saves them for deferred processing
private downloadRentalData() {
    def msgs = []
    
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    checkMemoryStatus()
    
    def pinDetails = getLockPinLengthDetails()
    if (pinDetails.pinLenError) {
        def msg = "YOUR LOCKS ARE CONFIGURED TO ACCEPT DIFFERENT CODE DIGIT LENGTHS, PROGRAMMING MAY FAIL!"
        log.error msg
        msgs << msg
    }
    def pinLen = finalPinLength(pinDetails)

    if (!locks) { // If there are no locks selected then just skip it all
    	def msg = "No locks selected, cannot calculate pin length needed to schedule automatic codes"
        log.trace msg
    } else if (!pinLen) { // If we don't have a pin length we can't program codes
        def msg = "No user code length configured for locks, cannot schedule automatic codes"
        log.error msg
        msgs << msg
    } else {
        log.trace "Using user code length ${pinLen as Integer} to schedule automatic user codes"
        getScheduleAirBnB(pinLen) // get AirBnB entries
        getScheduleVRBO(pinLen) // add VRBO entries
        getScheduleHomeAway(pinLen) // add HomeAway entries
        getScheduleBooking(pinLen) // add Booking.com entries
        getScheduleTripAdvisor(pinLen) // get TripAdvisor entries
        getScheduleExpedia(pinLen) // get Expedia entries
        getScheduleGeneric(pinLen) // get Generic entries

        // One it's all done successfully calculate the next time we want to check
        state.nextRentalUpdateCheck = now() + (rentalUpdateFrequency*60*1000) // x minutes from now
        log.debug "Next automatic calendar update after ${(new Date(state.nextRentalUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    }

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Updates the rental users information using the downloaded rental schedules
private processRentalUsers() {
    checkMemoryStatus()

    // Lets get the scheduled entries to update the lock users
    def criticalMsgs = [] // Must notify these messages
    def msgs = []
    def smsUsers = [] // Create list of users to SMS code to
    def invalidUsers = [] // List of users with invalid entries (phone/code missing etc)
    int i = (maxManualUsers ?: 0) + 1 // Rental users start after manual users
    log.trace "Programming up to ${maxRentalUsers} automatic users"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    def entries = [] // Collect all the calendar entries
    def programUsers = [] // Create a list of users to be updated/programmed
    def rentalUsers = getAllRentalUsers()?.sort { it.startDate } // (yyyy-MM-dd) Get a list of All Rental Users, programmed and empty, we want oldest startDate in the last, no startDate at beginning, we dont' need timezone here since we are just sorting with relative to each other and not comparing to current date/time
    def airBnBEntries = []
    def vrboEntries = []
    def homeAwayEntries = []
    def bookingEntries = []
    def tripAdvisorEntries = []
    def expediaEntries = []
    def genericEntries = []

    // Reset incase reservations were cancelled, if there is a checkin in today it will be updated (the changes won't commit to state until method exits so it's safe if there's a timeout)
    state.checkInNextRun = [:]
    state.checkOutNextRun = [:]

    // First clean up any old calendars renter data that's left over
    if (rentalUnitsCount && (rentalUnitsCount < maxRentalUnitsCount)) { // Keep compatibility with v1
        //log.debug "Clearing excess units ${(rentalUnitsCount + 1)} to ${maxRentalUnitsCount} renter saved entries"
        ((rentalUnitsCount + 1)..maxRentalUnitsCount).each { no -> // Wipe them clean
            atomicState."unit${no}Airbnb" = null
            atomicState."unit${no}Vrbo" = null
            atomicState."unit${no}HomeAway" = null
            atomicState."unit${no}Booking" = null
            atomicState."unit${no}TripAdvisor" = null
            atomicState."unit${no}Expedia" = null
            atomicState."unit${no}Generic" = null
            atomicState."unit${no}AirbnbUpdated" = null
            atomicState."unit${no}VrboUpdated" = null
            atomicState."unit${no}HomeAwayUpdated" = null
            atomicState."unit${no}BookingUpdated" = null
            atomicState."unit${no}TripAdvisorUpdated" = null
            atomicState."unit${no}ExpediaUpdated" = null
            atomicState."unit${no}GenericUpdated" = null
            atomicState."unit${no}AirbnbProcessed" = null
            atomicState."unit${no}VrboProcessed" = null
            atomicState."unit${no}HomeAwayProcessed" = null
            atomicState."unit${no}BookingProcessed" = null
            atomicState."unit${no}TripAdvisorProcessed" = null
            atomicState."unit${no}ExpediaProcessed" = null
            atomicState."unit${no}GenericProcessed" = null
        }
    }

    // Get the reservation entries
    def updates = ""
    unitSuffixes.each { no, suffix ->
        def airbnbEntry = atomicState."unit${no}Airbnb"
        def vrboEntry = atomicState."unit${no}Vrbo"
        def homeAwayEntry = atomicState."unit${no}HomeAway"
        def bookingEntry = atomicState."unit${no}Booking"
        def tripAdvisorEntry = atomicState."unit${no}TripAdvisor"
        def expediaEntry = atomicState."unit${no}Expedia"
        def genericEntry = atomicState."unit${no}Generic"
        def airbnbEntryUpdated = atomicState."unit${no}AirbnbUpdated"
        def vrboEntryUpdated = atomicState."unit${no}VrboUpdated"
        def homeAwayEntryUpdated = atomicState."unit${no}HomeAwayUpdated"
        def bookingEntryUpdated = atomicState."unit${no}BookingUpdated"
        def tripAdvisorEntryUpdated = atomicState."unit${no}TripAdvisorUpdated"
        def expediaEntryUpdated = atomicState."unit${no}ExpediaUpdated"
        def genericEntryUpdated = atomicState."unit${no}GenericUpdated"
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        airBnBEntries += airbnbEntry ?: []
        vrboEntries += vrboEntry ?: []
        homeAwayEntries += homeAwayEntry ?: []
        bookingEntries += bookingEntry ?: []
        tripAdvisorEntries += tripAdvisorEntry ?: []
        expediaEntries += expediaEntry ?: []
        genericEntries += genericEntry ?: []
        updates += (updates ? "\n" : "") + "${propertyName ? "property ${propertyName}" : "unit ${no}"}, AirBnB:${airbnbEntry?.size()} entries, updated ${airbnbEntryUpdated ? (new Date(airbnbEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, VRBO:${vrboEntry?.size()} entries, updated ${vrboEntryUpdated ? (new Date(vrboEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, HomeAway:${homeAwayEntry?.size()} entries, updated ${homeAwayEntryUpdated ? (new Date(homeAwayEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, Booking.com:${bookingEntry?.size()} entries, updated ${bookingEntryUpdated ? (new Date(bookingEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, TripAdvisor:${tripAdvisorEntry?.size()} entries, updated ${tripAdvisorEntryUpdated ? (new Date(tripAdvisorEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, Expedia:${expediaEntry?.size()} entries, updated ${expediaEntryUpdated ? (new Date(expediaEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}, Generic:${genericEntry?.size()} entries, updated ${genericEntryUpdated ? (new Date(genericEntryUpdated)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "never"}"
    }
    entries += airBnBEntries + vrboEntries + homeAwayEntries + bookingEntries + tripAdvisorEntries + expediaEntries + genericEntries // Save them all
    updates += "\n" + "Total entries:${entries.size()}"
    log.trace updates

    // Lets sort the combined list by start date
    entries?.sort { it.startDate ?: "21001231" } // (yyyyMMdd) We want earliest entries first, no startDate at the end, we dont' need timezone here since we are just sorting with relative to each other and not comparing to current date/time

    // Process each entry
    entries.each { entry ->
        //log.trace entry
        if (entry.name && entry.startDate && entry.expDate) { // Don't check for code or start/exp time here
            // Details about users checkin, checkout, phone and name
            def user = i as String
            def name = entry.name
            def manualUpdate = state.updatedUsers.find { it.name == name } // Check if this user has any manual updates to the startDate or expDate
            def code = entry.code
            def startDate = entry.uStartDate ? entry.startDate : (manualUpdate?.startDate ?: entry.startDate) // yyyyMMdd - Reservation start date, check if we have an updated reservation date (not adjusted for preactivation) else check if the startDate was manually updated (adjusted for preactivation) else take the original date (adjusted for preactivation)
            def startTime = entry.startTime ?: checkInTime // If we have a start time use it otherwise is checkin time
            def expDate = entry.uExpDate ? entry.expDate : (manualUpdate?.expDate ?: entry.expDate) // yyyyMMdd - Reservation end date, check if we have an updated reservation date else check if the expDate was manually updated else take the original date (required if expDate is set to before original expDate because current user will be removed)
            def expTime = entry.expTime ?: checkOutTime // If we have a expiration time use it otherwise use checkout time
            def updatedPreactivation = (state.rentalPreArrivalActivationDays != preArrivalActivationDays) // Has the default preactivation days been reset
            def uStartDate = entry.uStartDate // Do we have an updated reservation start date 
            def uExpDate = entry.uExpDate // Do we have an updated reservation exp date
            def updatedStartTime = (timeToday(state.checkInTime ?: checkInTime, timeZone) != timeToday(checkInTime, timeZone)) && !entry.startTime // If the default check in time has changed then reset it - only applied to users who don't have a calendar start time
            def updatedExpTime = (timeToday(state.checkOutTime ?: checkOutTime, timeZone) != timeToday(checkOutTime, timeZone)) && !entry.expTime // If the default check out time has changed then reset it - only applied to users who don't have a calendar end time
            def notify = rentalUserNotify == null ? true : rentalUserNotify // Default value is true if not defined
            def notifyCountUpdated = (state.rentalUserNotifyCount != rentalUserNotifyCount) // Has the number of notifications been reset
            def notifyCount = rentalUserNotifyCount ?: "" // Don't use null
            def bSource = entry.bSource // What's the source of the booking
            def userPhone = entry.phone // User's phone for AirBnB
            def no = entry.unit // Unit number
            def suffix = unitSuffixes[no] // Unit suffix
            def userLocks = (locks?.size() > 1) ? (settings."propertyLocks${unitSuffixes[no]}" ?: "") : "" // Selected locks, dont' use null
            def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
            def updatedCode = state.phonePattern."${suffix}${bSource}UpdateCodes" // Check if we have any property calendars with an overwrite request
            
            //log.trace "Rental user: $user, name: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, notify: $notify, notifyCount: $notifyCount, userLocks:$userLocks, propertyName:$propertyName"

            try { // Ensure we have valid dates to process the entry
                def currentUser = false // Is this an existing user
                // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone)) - (entry.startTime ? 0 : ((!uStartDate && manualUpdate?.startDate) ? 0 : preArrivalActivationDays)) // Renter activation date, compensate for automatic activation ahead of arrival, unless we're using a Manually adjusted date (already adjusted for preactivation), don't adjust for calendars with custom start times
                def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // Renter expiry date
                def expStr = exp.format("EEE MMM dd yyyy HH:mm z", timeZone)
                def scheduleCutoff = (new Date(now())) + (maxRentalDays ?: defaultRentalDays) // How many max days to schedule
                def sendSMSAfter = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone)) - (sendCodeToPhoneDays ?: minSendCodeToPhoneDays) // When to send SMS message to user

                // Check if there are any adjustments made to existing user and retain them
                // Only startDate, expDate, startTime, expTime, notify and notify count are customizable for each rental user (sometimes they may be blank due to platform bugs while updating), rest are kept in sync with the calendar
                def curr = rentalUsers.find { slot -> slot.name == name } // Check if have this user already programmed
                if (curr && curr.startTime && curr.expTime && curr.startDate && curr.expDate) {
                    def reservationStart = start // This is start date based on the reservation and adjusted for preactivation
                    def reservationExp = exp // This is expiry date based on the reservation

                    // Check for changes to time first since it will impact the startDate/expDate calculations
                    if (!updatedStartTime) { // If we don't have an updated start time use the existing time
                        startTime = curr.startTime
                    }
                    if (!updatedExpTime) { // If we don't have an updated expiration time use the existing time
                        expTime = curr.expTime
                    }
                    
                    // Check if we have a new updated code to use
                    if (!updatedCode && curr.code) { // AirBnB sometimes delays sending the phone number so we may have a blank entry stored, if so ignore it (NOTE: this means the user cannot have a blank manual override)
                        code = curr.code // Use the current code
                    }

                    // Recalculate activation start date, if we don't have an updated reservation date then use the existing date and convert from yyyy-MM-dd to yyyyMMdd
                    start = Date.parse("yyyyMMddHH:mmZ", (uStartDate ? startDate : curr.startDate.replace("-", "")) + timeToday(startTime, timeZone).format("HH:mmZ", timeZone)) - (entry.startTime ? 0 :(uStartDate ? preArrivalActivationDays : ((updatedPreactivation && !manualUpdate?.startDate) ? (preArrivalActivationDays - state.rentalPreArrivalActivationDays) : 0))) // Manual dates are already preactivated, only compensate for preactivation if we're have an updated original reservation start date or a change in the number of preactivation days (adjust for the number of days the existing startDate was already preactivated), don't adjust for calendars with custom start times
                    startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                    if (start != reservationStart) { // If the user has manually changed the start date/time then save it and recalculate the SMS date
                        if (curr.startDate.replace("-", "") != reservationStart.format("yyyyMMdd", timeZone)) { // If the startDate has changed (already adjusted for preactivation), update startDate
                            log.debug "Detected existing user $name in slot ${curr.user} start date changed from ${reservationStart.format("yyyyMMdd", timeZone)} to ${curr.startDate.replace("-", "")}"
                            def currStartDate = curr.startDate.replace("-", "") // convert yyyy-MM-dd to yyyyMMdd (manually adjusted dates are assumed to be preactivation adjusted)
                            // Save the updated date, if the manual startDate is older than the original startDate the user may not be downloaded by the rental data, force it to keep it
                            if (manualUpdate) { // Check if the adjustment already exists
                                manualUpdate.startDate = currStartDate // Update the startDate, groovy passes by reference
                            } else {
                                manualUpdate = [ name: name, startDate: currStartDate, orgExpDate: expDate ] // Update it here so that it can be referenced later if needed (expDate and startDate change at the same time)
                                state.updatedUsers << manualUpdate // First time, add it and also save the original expiration date to we know when to stop tracking it
                            }
                            startDate = currStartDate // Update the reservation startDate (manual dates are assumed to be adjusted for preactivation)
                            sendSMSAfter = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone)) - (sendCodeToPhoneDays ?: minSendCodeToPhoneDays) // When to send SMS message to user adjusted for with new manual startDate
                        }
                    }

                    // Recalculate activation expiry date, if we don't have an updated reservation date then use the existing date and convert from yyyy-MM-dd to yyyyMMdd
                    exp = Date.parse("yyyyMMddHH:mmZ", (uExpDate ? expDate : curr.expDate.replace("-", "")) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                    expStr = exp.format("EEE MMM dd yyyy HH:mm z", timeZone)
                    if (exp != reservationExp) { // If the user has manually changed the expiry date/time then save it
                        if (curr.expDate.replace("-", "") != reservationExp.format("yyyyMMdd", timeZone)) { // If the expDate has changed, update expDate
                            log.debug "Detected existing user $name in slot ${curr.user} expiration date changed from ${reservationExp.format("yyyyMMdd", timeZone)} to ${curr.expDate.replace("-", "")}"
                            def currExpDate = curr.expDate.replace("-", "") // convert yyyy-MM-dd to yyyyMMdd
                            // Save the updated date, if the manual expDate is older than the original expDate the user will be deleted so we need a way to check the updated expDate so it won't be recreated
                            if (manualUpdate) { // Check if the adjustment already exists
                                manualUpdate.expDate = currExpDate // Update the expDate, groovy passes by reference
                            } else {
                                manualUpdate = [ name: name, expDate: currExpDate, orgExpDate: expDate ] // Update it here so it can be referenced later if needed
                                state.updatedUsers << manualUpdate // First time, add it and also save the original expiration date
                            }
                            expDate = currExpDate // Update the reservation expDate
                        }
                    }

                    notify = curr.notify // Use saved settings
                    notifyCount = notifyCountUpdated ? notifyCount : curr.notifyCount // Use saved settings unless the main settings have been updated
                    //userLocks = ((locks?.size() > 1) && curr.userLocks ? curr.userLocks : userLocks) // Don't keep custom setting for userLocks, always use the latest unit settings

                    i = curr.user // Lets reuse the slot to reduce movement of codes which play havoc with some locks/meshes
                    currentUser = true
                    
                    //log.trace "Found existing user: $curr\nUpdated rental user: $user, name: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, notify: $notify, notifyCount: $notifyCount, userLocks: $userLocks, SMSAfter: ${sendSMSAfter.format("yyyyMMdd HH:mm", timeZone)}, activation: $startStr, expiration: $expStr"
                }
                
                if (sendCodeToPhone && (bSource == "AirBnB") && (sendSMSAfter <= new Date(now())) && (exp >= new Date(now()))) { // Check if we need to SMS the code to the user
                    if (!sendCodeToPhone.toLowerCase().contains("<code>")) {
                        def msg = "Cannot SMS code to user $name, please include <code> in text message template"
                        log.error "$msg\n$sendCodeToPhone"
                        criticalMsgs << msg
                    } else if (!userPhone) {
                        def msg = "Cannot SMS code to user $name, phone number not found in $propertyName booking"
                        //log.error msg
                        invalidUsers << [ name: name, msg: msg, expDate: expDate ]
                    } else {
                        //def msg = "Scheduling SMS to send to renter $name"
                        //log.trace msg
                        smsUsers << [ name: name, phone: userPhone, code: code, startDate: startDate, expDate: expDate, propertyName: propertyName ]
                    }
                }
                
                // Setup CheckIn and CheckOut, these can happen before a user is activated and after a user is removed so check before programming, only do this of we have a valid code for the user
                if (!code) { // If there's no code then notify owner
                    def msg = "No automatic code found for user $name in $propertyName"
                    //log.warn msg
                    invalidUsers << [ name: name, msg: msg, expDate: expDate ]
                } else if (maxRentalUsers) { // Only if we have automatic rental user slots defined
                    use (groovy.time.TimeCategory) {
                        def todayCheckIn = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(checkInTime, timeZone).format("HH:mmZ", timeZone)) - (settings."checkInOffset${no}" ?: 0).minutes // Adjust for early run
                        if (isDateToday(todayCheckIn)) { // If we have a user CheckIn scheduled today (startDate is not adjusted for preactivation)
                            state.checkInNextRun[(no as String)] = todayCheckIn.getTime() // Save as ms
                            def msg = "CheckIn actions for $name in $propertyName scheduled today at ${todayCheckIn.format("EEE MMM dd yyyy HH:mm z", timeZone)}"
                            log.debug msg
                        }

                        def todayCheckOut = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(checkOutTime, timeZone).format("HH:mmZ", timeZone)) + (settings."checkOutOffset${no}" ?: 0).minutes // Adjust for delayed run
                        if (isDateToday(todayCheckOut)) { // If we have a user CheckOut scheduled today (expDate is not adjusted for preactivation)
                            state.checkOutNextRun[(no as String)] = todayCheckOut.getTime() // Save in ms
                            def msg = "CheckOut actions for $name in $propertyName scheduled today at ${todayCheckOut.format("EEE MMM dd yyyy HH:mm z", timeZone)}"
                            log.debug msg
                        }
                    }
                }   
                
                // Program today and future reservations upto the maximum - scheduling will take care of activation, don't schedule today's users who are past check out, dont' schedule future users before check in time otherwise it sends notifications at midnight
                if ((start <= scheduleCutoff) && (exp >= new Date(now()))) {
                    if (!currentUser) { // If it's not a current user lets find an empty slot, else slot 0
                        i = rentalUsers.find { slot -> !slot.code }?.user ?: 0
                    }

                    // If we don't have an current/empty slot available lets check if the rentalUsers list contains a startDate later than this one and if so we'll take it's slot and replace it with this
                    if (!i && maxRentalUsers) { // If we don't have a program slot and we have defined atleast one rental user slot
                        def lastSlot = rentalUsers.size() ? rentalUsers.last() : [:] // Last entry is the latest startDate in this sorted list
                        // The lastSlot startDate is already adjusted for preactivation and so it the current start, so we can compare them
                        if (lastSlot && (Date.parse("yyyy-MM-ddHH:mmZ", lastSlot.startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone)) > start)) { // If the last entry is later than this entry, then lets replace the slot
                            i = lastSlot.user // Take the last slot
                            log.debug "Replacing ${lastSlot.name} starting ${lastSlot.startDate} in slot ${lastSlot.user} with ${name} in ${propertyName} starting ${start.format("yyyy-MM-dd", timeZone)}"
                        }
                    }
                    
                    if ((i > (maxManualUsers ?: 0)) && (i <= maxUserNames)) { // Program only as many rental slots as the available
                        rentalUsers.remove(rentalUsers.find { slot -> slot.user == i }) // Lets remove this slot from the list of available rentalUsers
                        //log.trace "Schedule rental new: ${!currentUser}, user: $i, name: $name, code: $code, startDate: ${start.format("yyyy-MM-dd", timeZone)}, startTime: $startTime, expDate: ${exp.format("yyyy-MM-dd", timeZone)}, expTime: $expTime, notify: $notify, notifyCount: $notifyCount, userLocks: $userLocks, propertyName: $propertyName"
                        programUsers << [ new: !currentUser, user: i, name: name, code: code, startDate: start.format("yyyy-MM-dd", timeZone), startTime: startTime, expDate: exp.format("yyyy-MM-dd", timeZone), expTime: expTime, notify: notify, notifyCount: notifyCount, userLocks: userLocks, propertyName: propertyName ]
                    } else if (maxRentalUsers) { // This can happen when you have more users per day than slots available (because of advanced enabling of codes leading to more than 2 users per day)
                        //def msg = "All automatic scheduling user slots are full, deferring scheduling renter $name with code $code to user $user, start at $startStr and expire on $expStr"
                        //log.debug msg
                        //msgs << msg
                    } else { // This can happen when you have more users per day than slots available because maxRentalUsers is 0
                        def msg = "No automatic scheduling user slots defined, not scheduling renter $name with code $code to user $user, start at $startStr and expire on $expStr"
                        log.warn msg
                    }
                }
            } catch (Exception e) { // Catch an invalid date, skip this entry and inform the user
                def msg = "Skipping incomplete reservation in ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    // Now update the slots
    programUsers.each { slot ->
        // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
        def start = Date.parse("yyyy-MM-ddHH:mmZ", slot.startDate + timeToday(slot.startTime, timeZone).format("HH:mmZ", timeZone))
        def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
        def exp = Date.parse("yyyy-MM-ddHH:mmZ", slot.expDate + timeToday(slot.expTime, timeZone).format("HH:mmZ", timeZone))
        def expStr = exp.format("EEE MMM dd yyyy HH:mm z", timeZone)
        if (slot.new) { // If this is a new user then we notify
            def msg = "${app.label} updating schedule: ${(rentalUnitsCount > 1) ? "$slot.propertyName renter" : "Renter"} $slot.name, code $slot.code in user $slot.user, start at $startStr and expire on $expStr"
            log.debug msg
            msgs << msg
        } else {
            //def msg = "${(rentalUnitsCount > 1) ? "$slot.propertyName renter" : "Renter"} $slot.user already scheduled with renter $slot.name with code $slot.code, start at $startStr and expire on $expStr"
            //log.trace msg
        }                    
    }
    updateRentalUsers(programUsers) // Update them together to avoid DB timeouts

    // Clean up any left over unused slots
    def removeUsers = []
    def unusedSlots = maxRentalUsers ? ((((maxManualUsers ?: 0) + 1)..maxUserNames) - programUsers.collect { it.user }) : [] // Unused slots are the all rental slots (starting at manualUsers + 1) available less the programmed slots
    unusedSlots.each { slot ->
        def user = slot as String
        def code = settings."userCodes${user}"
        def name = settings."userNames${user}"
        if (name || code) { // If it's not been cleared already
            def msg = "Removing automatic user $user $name from programming schedule"
            //msgs << msg // We don't need to notify user on clean up activites
            log.debug msg
            removeUsers << slot
        } else {
            //def msg = "Rental user $user already empty"
            //log.trace msg
        }
    }
    removeRentalUsers(removeUsers) // Clear all the slots
    
    // Update tracking counters since programming is done
    state.rentalUserNotifyCount = rentalUserNotifyCount
    state.rentalPreArrivalActivationDays = preArrivalActivationDays
    state.checkInTime = checkInTime
    state.checkOutTime = checkOutTime

    // Clean up manually updated users, keep until midnight of original expiration date or the updated expiration date whichever is later, we can compare them directly since they are both strings in the format yyyyMMdd
    state.updatedUsers?.removeAll { (it.orgExpDate || it.expDate) ? (Date.parse("yyyyMMddHH:mmZ", (it.orgExpDate > it.expDate ? it.orgExpDate : it.expDate) + timeToday("23:59", timeZone).format("HH:mmZ", timeZone)) < new Date(now())) : true } // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
    
    // Send SMS to users if needed
    if (smsUsers) {
        // Check if a rental programming SMS time restriction, if so wait until it's time to send
        if (withinRentalProgrammingNotificationTimes()) {
            smsUsers.each { sms ->
                def smsUser = state.sentSMS.find { track -> track.name == sms.name }
                if (!smsUser) { // If it's already sent then don't send it again
                    def message = fromSMSTemplate(sms.code, Date.parse("yyyyMMdd", sms.startDate), Date.parse("yyyyMMdd", sms.expDate), sms.propertyName) // We don't need timezone here since the date format is being changed and not being current to current date/time
                    sendText(sms.phone, message)
                    // Do this after it has successfully sent the message (incase of a timeout)
                    state.sentSMS.add(sms) // Save the name (unique) to the list of SMS users
                    def msg = "Sending SMS to ${sms.name} at ${sms.phone}: $message"
                    log.trace msg
                    criticalMsgs << msg // These are critical, we must notify owner for each SMS sent at anytime of the day
                } else {
                    // Update the expiration date/time so we don't end up sending it again if the exp date was extended by the user
                    def msg
                    if (sms.expDate > smsUser.expDate) { // Only update if date has been extended (we need to check upto atleast original expDate otherwise it'll send it again when it's downloaded next), if it's been shortened it'll eventually expire, since the dates are in yyyyMMdd format, you can compare the strings directly
                        smsUser.expDate = sms.expDate // Groovy passes by reference so smsUser will update the state variable
                        msg = "SMS already send to ${sms.name}, tracking updated and expires after ${sms.expDate}"
                    } else {
                        msg = "SMS already send to ${sms.name}, tracking expires after ${sms.expDate}"
                    }
                    log.trace msg
                }
            }
        } else {
            log.warn "Current time is outside rental property notification schedule, waiting until ${timeToday(rentalProgrammingNotificationsStart, tZ).format("HH:mm z", timeZone)} to send SMS"
        }
    }

    // Clean up SMS tracking list, on rental user midnight of expiration date, stop tracking it, if there's no expiry date, stop tracking it
    state.sentSMS?.removeAll { it.expDate ? (Date.parse("yyyyMMddHH:mmZ", it.expDate + timeToday("23:59", timeZone).format("HH:mmZ", timeZone)) < new Date(now())) : true } // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally

    // Report invalid users (once only per reservation)
    if (invalidUsers) {
        // Check if a rental programming notification time restriction since these errors cannot be logged silently
        if (withinRentalProgrammingNotificationTimes()) {
            invalidUsers.each { invalid ->
                if (!state.invalidUsers.find { track -> track.name == invalid.name }) { // If it's already sent then don't send it again
                    state.invalidUsers.add(invalid.collectEntries { it.key == "msg" ? [:] : [(it.key) : it.value] }) // Save the name (unique) to the list of invalid users, except the msg (to save memory)
                    log.error invalid.msg
                    criticalMsgs << invalid.msg // Critical message, must inform owner at any time of day
                } else {
                    def msg = "Invalid user ${invalid.name} already reported, tracking expires after ${invalid.expDate}"
                    log.trace msg
                }
            }
        } else {
            log.warn "Current time is outside rental property notification schedule, waiting until ${timeToday(rentalProgrammingNotificationsStart, tZ).format("HH:mm z", timeZone)} to report Invalid Automatic Codes"
        }
    }

    // Clean up invalid users tracking list, on rental user midnight of expiration date, stop tracking it, if there's no expiry date, stop tracking it
    state.invalidUsers?.removeAll { it.expDate ? (Date.parse("yyyyMMddHH:mmZ", it.expDate + timeToday("23:59", timeZone).format("HH:mmZ", timeZone)) < new Date(now())) : true } // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally

    // Update the last processed time after housekeeping is done
    unitSuffixes.each { no, suffix ->
        atomicState."unit${no}AirbnbProcessed" = now()
        atomicState."unit${no}VrboProcessed" = now()
        atomicState."unit${no}HomeAwayProcessed" = now()
        atomicState."unit${no}BookingProcessed" = now()
        atomicState."unit${no}TripAdvisorProcessed" = now()
        atomicState."unit${no}ExpediaProcessed" = now()
        atomicState."unit${no}GenericProcessed" = now()

        // Reset any code update requests
        bookingSources.each { bName, bSource ->
            state.phonePattern.remove("${suffix}${bSource}UpdateCodes") // Save space by removing unused variables
        }
    }

    // Last thing, these are critical messages, send them first and must be delivered at any time of the day
    criticalMsgs.each { msg ->
        sendNotifications(msg)
    }
    
    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Checks if the Date is today (ignores' time) using current TimeZone
private isDateToday(Date d1, Date d2 = new Date(now())) {
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    return ((d1.format("yyyy", timeZone) == d2.format("yyyy", timeZone)) && // Use current timeZone adjustment and not in UTC otherwise it returns incorrect results
            (d1.format("MM", timeZone) == d2.format("MM", timeZone)) &&
            (d1.format("dd", timeZone) == d2.format("dd", timeZone))
           )
}

// Converts the SMS template to a message to send
private fromSMSTemplate(code, start, exp, property) {
    return sendCodeToPhone?.replaceAll("(?i)<code>", code)?.replaceAll("(?i)<start>", start.format("MMM dd yyyy"))?.replaceAll("(?i)<end>", exp.format("MMM dd yyyy")).replaceAll("(?i)<property>", property)
}

// Download the iCalendar file asynchronously - does not follow redirect, returns code
private downloadiCalendar(url, data, callback, customHeaders = null) {
    //log.trace "Downloading URL: $url with Data:$data"
    
    // Download the iCalendar file
    try {
        def params = [
            uri: url,
            requestContentType: "*/*", // Default is application/json which doesn't work with many sites, Yahoo won't accept "text/calendar" or "text/*" or the default if not specified, VRBO/HomeAway won't accept "", use application/* or */* (accept all)
            //contentType: "", //"text/plain", // We don't have a specific content type we are sending or we are sending a plain text (Yahoo won't accept "text/plain")
            //tlsVersion: "TLSv1.2",
        ]
        
        if (customHeaders) {
            params.headers = customHeaders
        }
        
        asynchttp.get(callback, params, data) // asynchttp calls the callback with an error for an SSL failure
    } catch (e) {
        log.error "Exception while querying iCalendar: $e"
        return false
    }
    
    return true
}

// SYNC CALENDAR - httpGet follows redirects automatically
// TODO: Download the calendar schedule synchronously until ST fixes async, return an error string
private getScheduleSync(url, data, siteDetails, customHeaders = null) {
    def pinLen = data.pinLen
    def no = data.no
    def suffix = data.suffix
    def iCalName = siteDetails.iCalName // iCalendar identifier
    def asName = siteDetails.asName // atomicState identifier
    def siteName = siteDetails.siteName // Site name
    def processResponse = siteDetails.processResponse // Calendar response handler
    def msgs = []
    def retVal = ""

    def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null

    log.trace "Sync downloading ${siteName} calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${settings."iCalURL${iCalName}${suffix}"}"
    try {
        def params = [
            uri: url,
            //tlsVersion: "TLSv1.2",
        ]

        if (customHeaders) {
            params.headers = customHeaders
        }
        
        httpGet(params) { ret ->
            //log.trace "Received response from ${siteName} Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            if (ret.data) { // Update it if required, ST is not consistent with how it returns data
                ret.data = (ret.data instanceof String ? ret.data : (ret.data instanceof ByteArrayInputStream) ? new String(ret.data.buf) : "") // Convert the ByteArrayInputStream to a String
            }

            log.trace "Received sync ${siteName} response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, params=$data, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
            "${processResponse}"(ret, [pinLen: pinLen, no: no, suffix: suffix]) // Process the response
        }
    } catch (e) { // httpGet throws an exception on SSL failure
        retVal = e.toString()
        def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} ${siteName} calendar"
        log.error "${msg}: ${e}"
        if (!(retVal?.contains("handshake_failure") && !data.proxy)) { // If we have a SSL handshake error and not using a proxy, don't message user as we may retry with a proxy
            msg += ". Retrying in about ${rentalUpdateFrequency} minutes"
            msgs << msg
        }
    }

    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
    
    return retVal
}

// AIRBNB
// Converts the downloaded AirBnB iCalendar file into a map with with entry per day
private iCalToMapListAirBnB(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["DTEND;VALUE=DATE",":","DTSTART;"], ["DTSTART;VALUE=DATE",":","UID:"], ["UID",":","DESCRIPTION:"], ["CHECKIN",":","\\n"], ["CHECKOUT",":","\\n"], ["NIGHTS",":","\\n"], ["PHONE",":","\\n"], ["EMAIL",":","\\n"], ["PROPERTY",":","\\n"], ["SUMMARY",":","LOCATION:"], ["LOCATION",":",""] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["DTEND",":","\n"], ["DTSTART",":","\n"], ["PHONE",":","\\n"], ["SUMMARY",":","\n"], ["code","=","\\n"], ["Phone Number (Last 4 Digits)",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the AirBnB calendar schedule
private getScheduleAirBnB(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLAirBnB${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}Airbnb" = null
            atomicState."unit${no}AirbnbUpdated" = null
            //log.trace "No AirBnB calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix, proxy: true], processAirBnBResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} AirBnB calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading AirBnB calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the AirBnB calendar response - ASYNC
def processAirBnBResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLAirBnB${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug, status is null
            msg = "AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
            log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
            getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "AirBnB", asName: "Airbnb", siteName: "AirBnB", processResponse: "processAirBnBResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
            return // We're done here
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} AirBnB calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(proxyURL + cleanSecureUrl(rLocation), data + [proxy: true], processAirBnBResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} AirBnB calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }
    
    log.trace "Received AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processAirBnBResponse(ret, data)
}

// Parse the AirBnB calendar response
def processAirBnBResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in AirBnB response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case failed
    }
    
    if (!autoCodeAirBnB) {
        def msg = "AirBnB automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListAirBnB(iCal)
    
    def oldEntries = atomicState."unit${no}Airbnb" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["AirBnB"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout, phone and name
        def name = entry['SUMMARY']?.trim()
        if ((name?.toLowerCase()?.contains("reserved") && entry['code']) || ((name =~ /\(.*\)/) && !name?.toLowerCase().startsWith("pending:") && !name?.toLowerCase().contains("not available"))) { // Only take confirmed entries, they contain the reservation code between the () and doesn't start with "PENDING:" or contains "Not available"
            if (name?.toLowerCase()?.contains("reserved")) { // New format (last 4 digits of phone and no name)
                name = "Airbnb" + (addReservationIdToName ? " (" + entry['code']?.trim() + ")" : "")
            } else if (!addReservationIdToName) { // Old format (name and phone number)
                name = (name - ~/\(.*\)/)?.trim() // Remove the reservation id and keep just the name
            }
            
            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8) // CHECKIN and CHECKOUT format changes from country to country (03/21/2018, 21-03-2018, 2018-03-21) so we can't use that
            def startTime = checkInTime // Use host configured settings
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime // Use host configured settings
            def phone = (entry['PHONE'] ?: "+1111111" + entry['Phone Number (Last 4 Digits)'])?.trim()?.replaceAll(/[^0-9\+]/, "") // User's phone for AirBnB, keep only number and + (country code), new format doesn't have phone number, only last 4 digits so dummy up the rest
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeAirBnB, pinLen, phone, startDate, expDate, name)
            if (code == null) {
                def msg = "AirBnB unknown automatic code generation format: $autoCodeAirBnB"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "AirBnB Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "AirBnB reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, phone: phone, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in AirBnB ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }
    
    log.trace "Found ${entries.size()} AirBnB schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}Airbnb" = details
    atomicState."unit${no}AirbnbUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// VRBO
// Converts the downloaded VRBO/HomeAway iCalendar file into a map with with entry per day
private iCalToMapListVRBOHomeAway(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["UID",":","\\n"], ["DTSTAMP",":","\\n"], ["DTSTART",":","\\n"], ["DTEND",":","\\n"], ["SUMMARY",":","\\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["UID",":","\n"], ["DTSTART",":","\n"], ["DTEND",":","\n"], ["SUMMARY",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the VRBO calendar schedule
private getScheduleVRBO(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLVRBO${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}Vrbo" = null
            atomicState."unit${no}VrboUpdated" = null
            //log.trace "No VRBO calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix, proxy: true], processVRBOResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} VRBO calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading VRBO calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the VRBO calendar response - ASYNC
def processVRBOResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLVRBO${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug, status is null
            msg = "VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
            log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
            getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "VRBO", asName: "Vrbo", siteName: "VRBO", processResponse: "processVRBOResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
            return // We're done here
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} VRBO calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(proxyURL + cleanSecureUrl(rLocation), data + [proxy: true], processVRBOResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} VRBO calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }
    
    log.trace "Received VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processVRBOResponse(ret, data)
}

// Parse the VRBO calendar response
def processVRBOResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in VRBO response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeVRBO) {
        def msg = "VRBO automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListVRBOHomeAway(iCal)

    def oldEntries = atomicState."unit${no}Vrbo" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["VRBO"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout and name
        def name = entry['SUMMARY']?.trim()
        if (name?.toLowerCase().startsWith("reserved - ")) { // Only take confirmed reservations to schedule starting with "Reserved - "
            name = name.replaceAll("(?i)reserved - ", "")?.trim() + (addReservationIdToName ? " (" + entry['UID']?.take(8) + ")" : "") // Remove the header and keep the name and add the UID to uniquely identify it (repeat renters)

            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8)
            def startTime = checkInTime
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeVRBO, pinLen, "", startDate, expDate, name)
            if (code == null) {
                def msg = "VRBO unknown automatic code generation format: $autoCodeVRBO"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "VRBO Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "VRBO reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in VRBO ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} VRBO schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}Vrbo" = details
    atomicState."unit${no}VrboUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// HOMEAWAY
// Download the HomeAway calendar schedule
private getScheduleHomeAway(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLHomeAway${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}HomeAway" = null
            atomicState."unit${no}HomeAwayUpdated" = null
            //log.trace "No HomeAway calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix, proxy: true], processHomeAwayResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} HomeAway calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading HomeAway calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the HomeAway calendar response - ASYNC
def processHomeAwayResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLHomeAway${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug, status is null
            msg = "HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
            log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
            getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "HomeAway", asName: "HomeAway", siteName: "HomeAway", processResponse: "processHomeAwayResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy - TODO: httpGet fails with HomeAway server with handshake_failure error, FIX is to replace homeaway with vrbo in iCal URL
            return // We're done here
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} HomeAway calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(proxyURL + cleanSecureUrl(rLocation), data + [proxy: true], processHomeAwayResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} HomeAway calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }
    
    log.trace "Received HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processHomeAwayResponse(ret, data)
}

// Parse the HomeAway calendar response
def processHomeAwayResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in HomeAway response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeHomeAway) {
        def msg = "HomeAway automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListVRBOHomeAway(iCal)

    def oldEntries = atomicState."unit${no}HomeAway" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["HomeAway"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout and name
        def name = entry['SUMMARY']?.trim()
        if (name?.toLowerCase().startsWith("reserved - ")) { // Only take confirmed reservations to schedule starting with "Reserved - "
            name = name.replaceAll("(?i)reserved - ", "")?.trim() + (addReservationIdToName ? " (" + entry['UID']?.take(8) + ")" : "") // Remove the header and keep the name and add the UID to uniquely identify it (repeat renters)

            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8)
            def startTime = checkInTime
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeHomeAway, pinLen, "", startDate, expDate, name)
            if (code == null) {
                def msg = "HomeAway unknown automatic code generation format: $autoCodeHomeAway"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "HomeAway Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "HomeAway reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in HomeAway ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} HomeAway schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}HomeAway" = details
    atomicState."unit${no}HomeAwayUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// BOOKING.COM
// Converts the downloaded Booking.com iCalendar file into a map with with entry per day
private iCalToMapListBooking(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["UID",":","\\n"], ["DTSTART",":","\\n"], ["DTEND",":","\\n"], ["SUMMARY",":","\\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["UID",":","\n"], ["DTSTART",":","\n"], ["DTEND",":","\n"], ["SUMMARY",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the Booking.com calendar schedule
private getScheduleBooking(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLBooking${suffix}"?.trim()//?.replace("admin.booking.com/hotel/hoteladmin/ical.html", "admin.booking.com/fresa/extranet/sync_calendars/export/") // TODO: ST Async HTTP has a bug that it can't follow redirects and booking.com redirect, so let us redirect manually
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}Booking" = null
            atomicState."unit${no}BookingUpdated" = null
            //log.trace "No Booking.com calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix], processBookingResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Booking.com calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading Booking.com calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the Booking.com calendar response - ASYNC
def processBookingResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLBooking${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug or SSL handshake failure, status is null
            if (ret.getErrorMessage()?.contains("handshake_failure")) {
                if (!data.proxy) {
                    msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy request"
                    log.warn (msg + "\nSSL Handshake Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], processBookingResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                        msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Booking.com calendar proxy. Retrying in about ${rentalUpdateFrequency} minutes"
                        log.error msg
                    } else {
                        return // We're done here
                    }
                } else {
                    msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Booking", asName: "Booking", siteName: "Booking.com", processResponse: "processBookingResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            } else {            
                msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using synchronous request"
                log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                if (getScheduleSync(cleanSecureUrl(iCalUrl), data, [ iCalName: "Booking", asName: "Booking", siteName: "Booking.com", processResponse: "processBookingResponse" ])?.contains("handshake_failure")) { // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                    msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Booking", asName: "Booking", siteName: "Booking.com", processResponse: "processBookingResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            }
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Booking.com calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(cleanSecureUrl(rLocation), data, processBookingResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Booking.com calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {
            msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }

        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }

    log.trace "Received Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processBookingResponse(ret, data)
}

// Parse the Booking.com calendar response
def processBookingResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in Booking.com response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeBooking) {
        def msg = "Booking.com automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListBooking(iCal)

    def oldEntries = atomicState."unit${no}Booking" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["Booking"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout and name
        def name = entry['SUMMARY']?.trim()
        if (name?.toLowerCase().startsWith("closed - ") && !name?.toLowerCase().contains("not available")) { // Only take confirmed reservations starting with "CLOSED - " to schedule and skip private reservations containing "Not Available"
            name = name.replaceAll("(?i)closed - ", "")?.trim() + (addReservationIdToName ? " (" + entry['UID']?.take(8) + ")" : "") // Remove the header and keep the name and add the UID to uniquely identify it (repeat renters)

            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8)
            def startTime = checkInTime
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeBooking, pinLen, "", startDate, expDate, name)
            if (code == null) {
                def msg = "Booking.com unknown automatic code generation format: $autoCodeBooking"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "Booking.com Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "Booking.com reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in Booking.com ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} Booking.com schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}Booking" = details
    atomicState."unit${no}BookingUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// TRIPADVISOR
// Converts the downloaded TripAdvisor iCalendar file into a map with with entry per day
private iCalToMapListTripAdvisor(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["UID",":","\\n"], ["DTSTAMP",":","\\n"], ["DTSTART",":","\\n"], ["DTEND",":","\\n"], ["SUMMARY",":","\\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["DTSTART",":","\n"], ["DTEND",":","\n"], ["SUMMARY",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the TripAdvisor calendar schedule
private getScheduleTripAdvisor(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLTripAdvisor${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}TripAdvisor" = null
            atomicState."unit${no}TripAdvisorUpdated" = null
            //log.trace "No TripAdvisor calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix], processTripAdvisorResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} TripAdvisor calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading TripAdvisor calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the TripAdvisor calendar response - ASYNC
def processTripAdvisorResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLTripAdvisor${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug or SSL handshake failure, status is null
            if (ret.getErrorMessage()?.contains("handshake_failure")) {
                if (!data.proxy) {
                    msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy request"
                    log.warn (msg + "\nSSL Handshake Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], processTripAdvisorResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                        msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} TripAdvisor calendar proxy. Retrying in about ${rentalUpdateFrequency} minutes"
                        log.error msg
                    } else {
                        return // We're done here
                    }
                } else {
                    msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "TripAdvisor", asName: "TripAdvisor", siteName: "TripAdvisor", processResponse: "processTripAdvisorResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            } else {            
                msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using synchronous request"
                log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                if (getScheduleSync(cleanSecureUrl(iCalUrl), data, [ iCalName: "TripAdvisor", asName: "TripAdvisor", siteName: "TripAdvisor", processResponse: "processTripAdvisorResponse" ])?.contains("handshake_failure")) { // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                    msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "TripAdvisor", asName: "TripAdvisor", siteName: "TripAdvisor", processResponse: "processTripAdvisorResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            }
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} TripAdvisor calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(cleanSecureUrl(rLocation), data, processTripAdvisorResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} TripAdvisor calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }
    
    log.trace "Received TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processTripAdvisorResponse(ret, data)
}

// Parse the TripAdvisor calendar response
def processTripAdvisorResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in TripAdvisor response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeTripAdvisor) {
        def msg = "TripAdvisor automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListTripAdvisor(iCal)

    def oldEntries = atomicState."unit${no}TripAdvisor" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["TripAdvisor"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout and name
        def name = entry['SUMMARY']?.trim()
        if (name?.toLowerCase().startsWith("tripadvisor booking: ")) { // Only take confirmed reservations to schedule starting with "TripAdvisor booking: "
            name = name.replaceAll("(?i)tripadvisor booking: ", "")?.trim() // Remove the header and keep the name
            if (!addReservationIdToName) {
                name = (name - ~/\(.*\)/)?.trim() // Remove the reservation id and keep just the name
            }

            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8)
            def startTime = checkInTime
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeTripAdvisor, pinLen, "", startDate, expDate, name)
            if (code == null) {
                def msg = "TripAdvisor unknown automatic code generation format: $autoCodeTripAdvisor"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "TripAdvisor Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "TripAdvisor reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in TripAdvisor ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} TripAdvisor schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}TripAdvisor" = details
    atomicState."unit${no}TripAdvisorUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// EXPEDIA
// Converts the downloaded Expedia iCalendar file into a map with with entry per day
private iCalToMapListExpedia(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["UID",":","\\n"], ["DTSTAMP",":","\\n"], ["DTSTART",":","\\n"], ["DTEND",":","\\n"], ["SUMMARY",":","\\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["UID",":","\n"], ["DTSTART",":","\n"], ["DTEND",":","\n"], ["DESCRIPTION",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the Expedia calendar schedule
private getScheduleExpedia(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLExpedia${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}Expedia" = null
            atomicState."unit${no}ExpediaUpdated" = null
            //log.trace "No Expedia calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix], processExpediaResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Expedia calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading Expedia calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the Expedia calendar response - ASYNC
def processExpediaResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLExpedia${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug or SSL handshake failure, status is null
            if (ret.getErrorMessage()?.contains("handshake_failure")) {
                if (!data.proxy) {
                    msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy request"
                    log.warn (msg + "\nSSL Handshake Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], processExpediaResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                        msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Expedia calendar proxy. Retrying in about ${rentalUpdateFrequency} minutes"
                        log.error msg
                    } else {
                        return // We're done here
                    }
                } else {
                    msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Expedia", asName: "Expedia", siteName: "Expedia", processResponse: "processExpediaResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            } else {            
                msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using synchronous request"
                log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                if (getScheduleSync(cleanSecureUrl(iCalUrl), data, [ iCalName: "Expedia", asName: "Expedia", siteName: "Expedia", processResponse: "processExpediaResponse" ])?.contains("handshake_failure")) { // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                    msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Expedia", asName: "Expedia", siteName: "Expedia", processResponse: "processExpediaResponse" ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            }
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Expedia calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(cleanSecureUrl(rLocation), data, processExpediaResponseAsync)) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} Expedia calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }
    
    log.trace "Received Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processExpediaResponse(ret, data)
}

// Parse the Expedia calendar response
def processExpediaResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in Expedia response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeExpedia) {
        def msg = "Expedia automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListExpedia(iCal)

    def oldEntries = atomicState."unit${no}Expedia" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["Expedia"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout and name
        def name = entry['DESCRIPTION']?.trim()
        if (name?.toLowerCase().startsWith("reserved by ")) { // Only take confirmed reservations to schedule starting with "Reserved by "
            name = name.replaceAll("(?i)reserved by ", "")?.trim() + (addReservationIdToName ? " (" + entry['UID']?.take(8) + ")" : "") // Remove the header and keep the name and add the UID to uniquely identify it (repeat renters)

            // Dates are in the format YYYYMMDD
            def startDate = entry['DTSTART']?.trim()?.take(8)
            def startTime = checkInTime
            def expDate = entry['DTEND']?.trim()?.take(8)
            def expTime = checkOutTime
            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            def code = generateAutomaticCode(autoCodeExpedia, pinLen, "", startDate, expDate, name)
            if (code == null) {
                def msg = "Expedia unknown automatic code generation format: $autoCodeExpedia"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "Expedia Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "Expedia reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << [ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, unit: no, bSource: bSource ] // Don't have startTime, expTime and userLocks to save memory
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in Expedia ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} Expedia schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}Expedia" = details
    atomicState."unit${no}ExpediaUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// GENERIC/CUSTOM CALENDAR
// Converts the downloaded Generic iCalendar file into a map with with entry per day
private iCalToMapListGeneric(str) {
    def ret = []
    def days = []
    
    // Two ways to do this, with split vs matcher, it may be faster and without exception with split (since matcher can't get size in ST)
    days = str?.split("BEGIN:VEVENT|END:VEVENT")?.findAll { it.trim() }?.collect { it.trim() }

    /*def tmp = str =~ /(?s)(?<=BEGIN:VEVENT).*?(?=END:VEVENT)/
    int i = 0
    try {
        while (true) {
            if ((tmp[i] ?: "").trim()) {
                days << (tmp[i] ?: "").trim()
            }
            i++
        }
    } catch (Exception e) { } // Only way to get the get the regex groups is iterate until you're out of bounds*/

    days.each { day ->
        //log.trace day
        def dayMap = [:]
        //[ ["UID",":","\n"], ["DTSTAMP",":","\n"], ["DTSTART",":","\n"], ["DTEND",":","\n"], ["DTSTART;VALUE=DATE",":","\n"], ["DTEND;VALUE=DATE",":","\n"], ["SUMMARY",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them
        [ ["DTSTART",":","\n"], ["DTEND",":","\n"], ["DESCRIPTION",":","<unfold>"], ["SUMMARY",":","\n"] ].each { key, token, eol -> // Identify which keys we want to extract and the token and delimiter for them, DESCRIPTION is multi line so '<unfold>' it as per RFC 5545
            dayMap.put(key, getKeyValue(day, key, token, eol))
        }
        //log.trace "$dayMap\n$day"
        
        ret << dayMap
    }
                
    //log.trace ret
    
    return ret
}

// Download the Generic calendar schedule
private getScheduleGeneric(pinLen) {
    def msgs = []
    unitSuffixes.each { no, suffix -> 
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null
        def iCalUrl = settings."iCalURLGeneric${suffix}"?.trim()
        if (!iCalUrl) { // Nothing to do
            atomicState."unit${no}Generic" = null
            atomicState."unit${no}GenericUpdated" = null
            //log.trace "No custom calendar URL configured for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
            return // Move on
        }

        if (!downloadiCalendar(cleanSecureUrl(iCalUrl), [pinLen: pinLen, no: no, suffix: suffix], processGenericResponseAsync, [ "Identifier": getIdentifier() ])) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier
            def msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} custom calendar. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error msg
            msgs << msg
            return // Move on to the next unit
        } else {
            log.trace "Downloading custom calendar for ${propertyName ? "property ${propertyName}" : "unit ${no}"}\n${iCalUrl}"
        }
    }
    
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}

// Parse the Generic calendar response - ASYNC
def processGenericResponseAsync(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null
    def iCalUrl = settings."iCalURLGeneric${suffix}"?.trim()

    if (ret.hasError()) {
        def msg
        def rLocation = ret.headers?.location ?: ret.headers?.Location // Some shards return the redirect in location, others in Location
        // ST Async HTTP has a bug that it can't follow redirects, so check if that's the error and then try a sync httpGet
        if (!ret.status) { // When it's a redirect error bug or SSL handshake failure, status is null
            if (ret.getErrorMessage()?.contains("handshake_failure")) {
                if (!data.proxy) {
                    msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy request"
                    log.warn (msg + "\nSSL Handshake Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    if (!downloadiCalendar(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], processGenericResponseAsync, [ "Identifier": getIdentifier() ])) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier, fix GCM cipher negotiations through proxy
                        msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} custom calendar proxy. Retrying in about ${rentalUpdateFrequency} minutes"
                        log.error msg
                    } else {
                        return // We're done here
                    }
                } else {
                    msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Generic", asName: "Generic", siteName: "custom calendar", processResponse: "processGenericResponse" ], [ "Identifier": getIdentifier() ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            } else {            
                msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying using synchronous request"
                log.warn (msg + "\nRedirect Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                if (getScheduleSync(cleanSecureUrl(iCalUrl), data, [ iCalName: "Generic", asName: "Generic", siteName: "custom calendar", processResponse: "processGenericResponse" ], [ "Identifier": getIdentifier() ])?.contains("handshake_failure")) { // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier
                    msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an proxy SSL handshake error: ${ret.getErrorMessage()}. Retrying using proxy synchronous request"
                    log.warn (msg + "\nSSL Handshake proxy Exception while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\n${iCalUrl}")
                    getScheduleSync(proxyURL + cleanSecureUrl(iCalUrl), data + [proxy: true], [ iCalName: "Generic", asName: "Generic", siteName: "custom calendar", processResponse: "processGenericResponse" ], [ "Identifier": getIdentifier() ]) // TODO: Run synch httpGet until ST fixes http async, add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier, fix GCM cipher negotiations through proxy
                    return // We're done here
                }
            }
        } else if ([ 301, 302, 303, 304, 305, 306, 307, 308 ].any { status -> status == ret.status } && rLocation) { // Sometimes ST doesn't handle redirect propertly, so let us handle it
            msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} redirected, retrying redirect:\n${rLocation}"
            log.warn msg
            if (iCalUrl == rLocation?.trim()) { // We shouldn't be stuck in a loop
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} custom calendar, redirect loop. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else if (!downloadiCalendar(cleanSecureUrl(rLocation), data, processGenericResponseAsync, [ "Identifier": getIdentifier() ])) { // Add the leading https if required and only use https as AirBnB/VRBO/HomeAway etc only use https now, add identifier
                msg = "Error downloading ${propertyName ? "property ${propertyName}" : "unit ${no}"} custom calendar redirect. Retrying in about ${rentalUpdateFrequency} minutes"
                log.error msg
            } else {
                return // We're done here
            }
        } else {            
            msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned an error: ${ret.getErrorMessage()}. Retrying in about ${rentalUpdateFrequency} minutes"
            log.error (msg + "\nException while querying: status ${ret.status}, warning ${ret.warningMessages}, error ${ret.errorData}\nheaders=${ret.headers}")
        }
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return
    }
    
    if (ret.warningMessages) {
        def msg
        msg = "Custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"} returned a warning: ${ret.warningMessages?.join("\n")}"
        log.warn msg
        
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // TODO: Should we try to continue here??
    }

    log.trace "Received custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}, status=${ret.status}, warning=${ret.warningMessages}, params=$data, json=${ret.json?.size()} characters, rawData:${ret.data?.size()} characters, headers=${ret.headers?.size()} fields"
    
    processGenericResponse(ret, data)
}

// Parse the Generic calendar response
def processGenericResponse(ret, data) {
    def pinLen = data?.pinLen // Pen length
    def no = data?.no // Unit no
    def suffix = data?.suffix // Unit suffix
    def propertyName = no ? (settings."propertyName${unitSuffixes[no]}" ?: "") : "" // Don't use null

    def msgs = []
    def iCal = ret.data?.trim() // Raw iCalendar data
    
    if (pinLen > maxAutoPinLen) {
        def msg = "Maximum pin length allowed is ${maxAutoPinLen} digits, lock configured to accept ${pinLen} digits"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    if (!iCal || !iCal?.startsWith("BEGIN:VCALENDAR")) { // If it's empty or isn't a VCALENDAR then something is wrong
        def msg = "No reservation data available in custom calendar response from ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
        log.error msg
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            sendNotifications(msg)
        } else {
            sendNotificationEvent(msg)
        }
        return // We're done here - special case it failed
    }

    if (!autoCodeGeneric) {
        def msg = "Custom calendar automatic code generation format not defined in Property Settings"
        log.error msg
        sendNotifications(msg) // Last thing to avoid timeout
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    //log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Process the calendar into usable entries
    def entries = iCalToMapListGeneric(iCal)

    def oldEntries = atomicState."unit${no}Generic" ?: [] // Get the last update to check if reservation dates have been updated
    def details = []
    def bSource = bookingSources["Generic"]

    // First sort by Start date since we will keep only the earliest entry required (YYYYMMDD format, no dates to be ignored)
    entries = entries?.sort { it ? (it['DTSTART']?.trim()?.take(8) ?: "21001231") : "21001231" }

    // Reset codes if we detect a change in the custom phone number markers
    if (settings."iCalGeneric${suffix}PhonePattern" && (autoCodeGeneric == "phone")) {
        if ((state.phonePattern."${suffix}PhonePatternStart" != settings."iCalGeneric${suffix}PhonePatternStart") || (state.phonePattern."${suffix}PhonePatternEnd" != settings."iCalGeneric${suffix}PhonePatternEnd")) { // Check of the phone patterns for this iCal has changed
            log.debug "Detected a change in phone number pattern matching, marking to overwriting existing user codes with new codes this iCalendar reservations"
            state.phonePattern."${suffix}PhonePatternStart" = settings."iCalGeneric${suffix}PhonePatternStart" // Save new pattern
            state.phonePattern."${suffix}PhonePatternEnd" = settings."iCalGeneric${suffix}PhonePatternEnd" // Save new pattern
            state.phonePattern."${suffix}${bSource}UpdateCodes" = true // Mark it so processRentalUsers can update the codes
        }
    }

    // Find the entry for today
    for (entry in entries) {
        // Details about users checkin, checkout, phone and name
        def name = entry['SUMMARY']?.trim()
        if (name &&
            (settings."iCalGeneric${suffix}IncSummary" ? name?.toLowerCase().startsWith(settings."iCalGeneric${suffix}IncSummary"?.toLowerCase()) : true) &&
            (settings."iCalGeneric${suffix}ExlSummary" ? !name?.toLowerCase().startsWith(settings."iCalGeneric${suffix}ExlSummary"?.toLowerCase()) : true)
           ) { // Only take confirmed reservations to schedule starting with "Reserved by "
            if (settings."iCalGeneric${suffix}IncSummary") {
                name = name.replaceFirst("^(?i)\\Q" + settings."iCalGeneric${suffix}IncSummary" + "\\E", "")?.trim()// Remove the header and keep the name, regex literal string match, ignore case, starting at beginning of line
            }
            
            // Check if we are using calendar start/end times
            def calStartDate
            def calExpDate
            def calStartTime
            def calExpTime
            if (settings."iCalGeneric${suffix}UseTime") {
                try {
                    def dtStart = entry['DTSTART']?.trim()
                    if (dtStart.size() >=15) { // If this is yyyyMMddTHHmmssZ e.g. 20201018T142016Z (ISO 8601 UTC time) or yyyyMMddTHHmmss e.g. 20201018T142016 (ISO 8601 local time)
                        use (groovy.time.TimeCategory) {
                            def dts = Date.parse("yyyyMMdd'T'HHmmss" + (dtStart.endsWith("Z") ? "X" : ""), dtStart) // Ajust for GMT (Z) if required, for local time (no Z) we need to adjust for the timeZone offset to counter the format(timeZone)
                            dts -= ((settings."iCalGeneric${suffix}StartOffset" ?: 0) as Integer).minutes // If we have a start time offset
                            calStartTime = (dts - (dtStart.endsWith("Z") ? 0 : (timeZone.getOffset(dts.time)).milliseconds)).format("yyyy-MM-dd'T'HH:mm:ss.SSSZ", timeZone) // ST ISO-8601 "time" input format 2020-02-05T11:18:00.000-0500
                            calStartDate = calStartTime.take(10).replace("-", "") // Keep the date YYYYMMDD
                        }
                    } else {
                        def msg = "Skipping invalid start date/time entry in custom calendar ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name}"
                        msgs << msg
                        log.warn(msg + "\n$e")
                        continue // We're done with this entry
                    }

                    def dtEnd = entry['DTEND']?.trim()
                    if (dtEnd.size() >=15) { // If this is yyyyMMddTHHmmssZ e.g. 20201018T142016Z (ISO 8601 UTC time) or yyyyMMddTHHmmss e.g. 20201018T142016 (ISO 8601 local time)
                        use (groovy.time.TimeCategory) {
                            def dte = Date.parse("yyyyMMdd'T'HHmmss" + (dtEnd.endsWith("Z") ? "X" : ""), dtEnd) // Ajust for GMT (Z) if required, for local time (no Z) we need to adjust for the timeZone offset to counter the format(timeZone)
                            dte += ((settings."iCalGeneric${suffix}EndOffset" ?: 0) as Integer).minutes // If we have a end time offset
                            calExpTime = (dte - (dtStart.endsWith("Z") ? 0 : (timeZone.getOffset(dte.time)).milliseconds)).format("yyyy-MM-dd'T'HH:mm:ss.SSSZ", timeZone) // ST ISO-8601 "time" input format 2020-02-05T11:18:00.000-0500
                            calExpDate = calExpTime.take(10).replace("-", "") // Keep the date YYYYMMDD
                        }
                    } else {
                        def msg = "Skipping invalid end date/time entry in custom calendar ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name}"
                        msgs << msg
                        log.warn(msg + "\n$e")
                        continue // We're done with this entry
                    }
                } catch (Exception e) { // Skip invalid entries but inform the user
                    def msg = "Skipping invalid date/time entry in custom calendar ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name}"
                    msgs << msg
                    log.warn(msg + "\n$e")
                    continue // We're done with this entry
                }
            }
            
            // Dates are in the format YYYYMMDD
            def startDate = calStartDate ?: entry['DTSTART']?.trim()?.take(8) // Use the calendar date if set because it may be adjusted for GMT (Z)
            def startTime = calStartTime ?: checkInTime // Use the calendar time if set
            def expDate = calExpDate ?: entry['DTEND']?.trim()?.take(8) // Use the calendar date if set because it may be adjusted for GMT (Z)
            def expTime = calExpTime ?: checkOutTime // Use the calendar time if set
            
            def phone
            def entryDesc = entry['DESCRIPTION'] ?: ""
            def phoneMarkerStart = settings."iCalGeneric${suffix}PhonePatternStart" ?: ""
            def phoneMarkerEnd = settings."iCalGeneric${suffix}PhonePatternEnd" ?: ""
            if (settings."iCalGeneric${suffix}PhonePattern") { // Do we have a custom phone marker pattern
                if (entryDesc.size() > (phoneMarkerStart.size() + phoneMarkerEnd.size())) { // If we have something to process
                    if (phoneMarkerStart && !entryDesc.toLowerCase().contains(phoneMarkerStart.toLowerCase())) { // If the start marker is missing, don't process it
                        phone = "" // Missing marker, ignore it
                    } else {
                        def startPos = phoneMarkerStart ? (entryDesc.toLowerCase().indexOf(phoneMarkerStart.toLowerCase()) + phoneMarkerStart.size()) : 0
                        if (phoneMarkerEnd && !entryDesc.toLowerCase().substring(startPos).contains(phoneMarkerEnd.toLowerCase())) { // If the end marker is missing, don't process it
                            phone = "" // Missing marker, ignore it
                        } else {
                            def endPos = phoneMarkerEnd ? entryDesc.toLowerCase().indexOf(phoneMarkerEnd.toLowerCase(), startPos) : entryDesc.size()
                            phone = entryDesc.substring(startPos, endPos)?.trim()?.replaceAll(/[^0-9\+]/, "") // User's phone is in description between markers, keep only number and + (country code)
                        }
                    }
                } else {
                    phone = "" // Nothing to process
                }
            } else {
                phone = entryDesc?.trim()?.replaceAll(/[^0-9\+]/, "") ?: ""// User's phone is in description, keep only number and + (country code)
            }

            //def userLocks = ((locks?.size() > 1) && settings."propertyLocks${suffix}" ? (locks*.id?.every { settings."propertyLocks${suffix}"?.contains(it) } ? "" : settings."propertyLocks${suffix}") : "") // Only save the user locks if they aren't all (to save state variable space in ST has a paltry 100K space)

            // Add the UID to uniquely identify it (repeat renters or same name renters)
            if (addReservationIdToName) {
                def uid = startDate?.drop(2) + expDate?.drop(2) // The UID of many iCals like Lodgify and RentalUnited keep changing for every download so we can't use those, lets use the start/end date (YYMMDD) as they are constant across all iCals for each reservation (if it changes it'll be treated as a new reservation)
                //java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5") // Convert the UID to a hash so it's unique since we have no way to know which part of the UID is unique
                //md.update(uid?.trim()?.getBytes("UTF-8"))
                //def uidHash = String.format("%032x", new BigInteger(1, md.digest())) // Convert it to a unique MD5 hash UID
                name += " (" + uid?.take(12) + ((calStartTime && calExpTime) ? (calStartTime.drop(11).take(5) + calExpTime.drop(11).take(5)).replace(":", "") : "") + ")" // We don't need to hash it since start/end dates unique anyways for each reservation, if we're using calendar times when tag on hhmm also for repeat names
            }
            
            def code = generateAutomaticCode(autoCodeGeneric, pinLen, phone, startDate, expDate, name)
            if (code == null) {
                def msg = "Custom calendar unknown automatic code generation format: $autoCodeGeneric"
                log.error msg
                sendNotifications(msg) // Last thing to avoid timeout
                return // We're done here
            }

            //log.trace "Custom calendar Rental entry: $name, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, unit: $no"

            try { // Verify that we have valid date/times and check if any changes in reservation dates
                def exp = Date.parse("yyyyMMddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                def start = Date.parse("yyyyMMddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                def oldEntry = oldEntries?.find { it.name == name } // Match by name
                def uStartDate = ((oldEntry && startDate) ? (oldEntry.startDate != startDate) : false)
                def uExpDate = ((oldEntry && expDate) ? (oldEntry.expDate != expDate) : false)
                if ((uStartDate || uExpDate) && startDate && expDate) { // If we have a valid entry notify user
                    // Sometimes old calendar entries are updated, so ignore them and only check for reservations who's end date is today or afterwards
                    def oldExp = Date.parse("yyyyMMddHH:mmZ", (oldEntry.expDate ?: expDate) + timeToday(expTime, timeZone).format("HH:mmZ", timeZone)) // If old doesn't exist, use current (since we could be in here from an updated start date)
                    if ((oldExp >= new Date(now())) || (exp >= new Date(now()))) { // If the old or now expiration is in future (i.e. active or to become active)
                        def dtMsg = ""
                        if (uStartDate) {
                            def oldStart = Date.parse("yyyyMMddHH:mmZ", oldEntry.startDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                            def startStr = start.format("MMM dd", timeZone)
                            def oldStartStr = oldStart.format("MMM dd", timeZone)
                            dtMsg += "start date changed from ${oldStartStr} to ${startStr}"
                        }

                        if (uExpDate) {
                            def expStr = exp.format("MMM dd", timeZone)
                            def oldExpStr = oldExp.format("MMM dd", timeZone)
                            dtMsg += (uStartDate ? " and " : "") + "end date changed from ${oldExpStr} to ${expStr}"
                        }

                        def msg = "Custom calendar reservation ${dtMsg} for ${name} in ${propertyName ? "property ${propertyName}" : "unit ${no}"}"
                        msgs << msg
                        log.trace msg
                    }
                }
                
                // Save it only if expiration is after today + max manual extension or the date has changed and upto the max rental users entry limit + possible expired extensions (limit amount of data being saved since ST's state limit is a paltry 100K)
                def manualUpdate = state.updatedUsers.find { it.name == name } // Check if we have an active manual update (date) for this renter, if so keep the entry so that we can reduce maxExtendDays to 1
                if (maxRentalUsers && // Process only if we have any rental users defined
                    (manualUpdate || // Always keep manual updates
                     ((uStartDate || uExpDate || ((exp + maxExtendDays) >= new Date(now()))) &&
                      (details.size() <= (state.updatedUsers.size() + maxExtendDays + maxRentalUsers + (details.findAll { it.uStartDate || it.uExpDate }.size())))))) { // Adjust for any extra entries we are keeping due to updated start/exp dates beyond the max rental users
                    details << ([ name: name, code: code, startDate: startDate, uStartDate: uStartDate, expDate: expDate, uExpDate: uExpDate, phone: phone, unit: no, bSource: bSource ] + ((calStartTime && calExpTime) ? [startTime: startTime, expTime: expTime] : [:])) // Don't have userLocks to save memory, use startTime, expTime only if required
                }
            } catch (Exception e) { // Skip invalid entries but inform the user
                def msg = "Skipping invalid entry in custom calendar ${propertyName ? "property ${propertyName}" : "unit ${no}"} for ${name} starting ${startDate}, ending ${expDate}"
                msgs << msg
                log.warn(msg + "\n$e")
            }
        }
    }

    log.trace "Found ${entries.size()} custom calendar schedules, processed ${details.size()} entries for ${propertyName ? "property ${propertyName}" : "unit ${no}"}"

    // Save it
    atomicState."unit${no}Generic" = details
    atomicState."unit${no}GenericUpdated" = now()

    // Do this in the end otherwise it may timeout
    if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
        msgs.each { msg -> sendNotifications(msg) }
    } else {
        msgs.each { msg -> sendNotificationEvent(msg) }
    }
}


// SUPPORT FUNCTIONS
// Find the next empty rental slot if available
private findEmptyRentalSlot() {
    for (int i = (maxManualUsers ?: 0) + 1; i <= maxUserNames; i++) { // Rental users start after manual users
        if (!settings."userCodes${i}") { // We found the empty slot (it shouldn't have a code)
            return i // We're done here
        }
    }

    return 0 // No empty slot available
}

// Gets all the Manual Users
private getAllManualUsers() {
    def rets = []
    
    for (int i = 1; i <= (maxManualUsers ?: 0); i++) { // Starts with manual users slot 1
        def ret = [:]
        // Get settings from the slot
        ret.user = i
        ret.name = settings."userNames${i}"
        ret.code = settings."userCodes${i}"
        ret.type = settings."userType${i}"
        ret.startDate = settings."userStartDate${i}"
        ret.expDate = settings."userExpireDate${i}"
        ret.startTime = settings."userStartTime${i}"
        ret.expTime = settings."userExpireTime${i}"
        ret.userLocks = settings."userLocks${i}"

        ret.each { ((it.value == "null") || (it.value == null)) ? it.value = "" : "" } // The platform reads the values as a string sometimes, if anything is 'null' replace it with empty

        ret.notify = (settings."userNotify${i}" && (settings."userNotify${i}" != "null")) ? settings."userNotify${i}".toBoolean() : false // Don't use null and save a bool
        ret.notifyCount = (settings."userNotifyUseCount${i}" && (settings."userNotifyUseCount${i}" != "null")) ? (settings."userNotifyUseCount${i}" as Integer) : "" // Don't use null and save as an integer

        //log.trace "Found manual user $name in slot $i, settings: ${ret.inspect()}"
        rets << ret
    }

    return rets
}

// Gets all the Rental Users
private getAllRentalUsers() {
    def rets = []
    
    for (int i = (maxManualUsers ?: 0) + 1; i <= maxUserNames; i++) { // Rental users start after manual users
        def ret = [:]
        // Get settings from the slot
        ret.user = i
        ret.name = settings."userNames${i}"
        ret.code = settings."userCodes${i}"
        ret.type = settings."userType${i}"
        ret.startDate = settings."userStartDate${i}"
        ret.expDate = settings."userExpireDate${i}"
        ret.startTime = settings."userStartTime${i}"
        ret.expTime = settings."userExpireTime${i}"
        ret.userLocks = settings."userLocks${i}"

        ret.each { ((it.value == "null") || (it.value == null)) ? it.value = "" : "" } // The platform reads the values as a string sometimes, if anything is 'null' replace it with empty

        ret.notify = (settings."userNotify${i}" && (settings."userNotify${i}" != "null")) ? settings."userNotify${i}".toBoolean() : false // Don't use null and save a bool
        ret.notifyCount = (settings."userNotifyUseCount${i}" && (settings."userNotifyUseCount${i}" != "null")) ? (settings."userNotifyUseCount${i}" as Integer) : "" // Don't use null and save as an integer

        //log.trace "Found rental user $name in slot $i, settings: ${ret.inspect()}"
        rets << ret
    }

    return rets
}

// Get the user details by slot number
private findUserSlot(i) {
    def ret = [:]

    // Get settings from the old slot
    ret.user = i
    ret.name = settings."userNames${i}"
    ret.code = settings."userCodes${i}"
    ret.type = settings."userType${i}"
    ret.startDate = settings."userStartDate${i}"
    ret.expDate = settings."userExpireDate${i}"
    ret.startTime = settings."userStartTime${i}"
    ret.expTime = settings."userExpireTime${i}"
    ret.userLocks = settings."userLocks${i}"

    ret.each { ((it.value == "null") || (it.value == null)) ? it.value = "" : "" } // The platform reads the values as a string sometimes, if anything is 'null' replace it with empty

    ret.notify = (settings."userNotify${i}" && (settings."userNotify${i}" != "null")) ? settings."userNotify${i}".toBoolean() : false // Don't use null and save a bool
    ret.notifyCount = (settings."userNotifyUseCount${i}" && (settings."userNotifyUseCount${i}" != "null")) ? (settings."userNotifyUseCount${i}" as Integer) : "" // Don't use null and save as an integer

    //log.trace "Found existing rental slot $name in slot $i, settings: ${ret.inspect()}"
    return ret
}

// Checks if there is a rental user by the name and returns the details
private findRentalUser(name) {
    def ret = [:]
    
    for (int i = (maxManualUsers ?: 0) + 1; i <= maxUserNames; i++) { // Rental users start after manual users
        if (settings."userNames${i}" == name) { // We found the slot
            // Get settings from the old slot
            ret.user = i
            ret.name = settings."userNames${i}"
            ret.code = settings."userCodes${i}"
            ret.type = settings."userType${i}"
            ret.startDate = settings."userStartDate${i}"
            ret.expDate = settings."userExpireDate${i}"
            ret.startTime = settings."userStartTime${i}"
            ret.expTime = settings."userExpireTime${i}"
            ret.userLocks = settings."userLocks${i}"

            ret.each { ((it.value == "null") || (it.value == null)) ? it.value = "" : "" } // The platform reads the values as a string sometimes, if anything is 'null' replace it with empty

            ret.notify = (settings."userNotify${i}" && (settings."userNotify${i}" != "null")) ? settings."userNotify${i}".toBoolean() : false // Don't use null and save a bool
            ret.notifyCount = (settings."userNotifyUseCount${i}" && (settings."userNotifyUseCount${i}" != "null")) ? (settings."userNotifyUseCount${i}" as Integer) : "" // Don't use null and save as an integer

            //log.trace "Found existing rental user $name in slot $i, settings: ${ret.inspect()}"
            break // We're done here
        }
    }

    return ret
}

// Update rental user settings in the app
private void updateRentalUsers(slots) {
    def map = [:] // Consolidate them to avoid DB timeouts
    slots?.each { slot ->
        def user = slot.user
        def name = slot.name
        def code = slot.code
        def startDate = slot.startDate
        def startTime = slot.startTime
        def expDate = slot.expDate
        def expTime = slot.expTime
        def notify = slot.notify
        def notifyCount = slot.notifyCount
        def userLocks = slot.userLocks

        //log.trace "Updating settings user: $user, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime, notify: $notify, notifyCount: $notifyCount, userLocks: $userLocks"

        // Write all settings in the new slot, use "" for empty/no value instead of null
        map["userNames${user}"] = (name ?: "") // Set the new name
        map["userCodes${user}"] = (code ?: "") // Set the new code
        map["userType${user}"] = ("Expire on") // Always expire one type
        map["userStartDate${user}"] = (startDate ?: "") // Set start date
        map["userExpireDate${user}"] = (expDate ?: "") // Set expire date
        map["userStartTime${user}"] = (startTime ?: "") // Set start time
        map["userExpireTime${user}"] = (expTime ?: "") // Set expire time
        map["userNotify${user}"] = ((notify == null) ? "" : notify as String) // Enable notifications for user, use "" for null and save true/false as string
        map["userNotifyUseCount${user}"] = (notifyCount ?: "") // How many notifications for user (0 can default as empty)
        map["userLocks${user}"] = (userLocks ?: "") // Set user locks
        map["userOverrideUnlockActions${user}"] = ("") // No custom actions for rental users, can't use false since it takes it as a string
        map["userOverrideNotifications${user}"] = ("") // No custom notifications for rental users
    }
    
    if (map) {
        updateSettings(map)
    }
}

// Remove rental user settings called from a runIn offline
def removeRentalUsersOffline(evt) {
    log.trace "Offline removing settings users: ${(evt.data?.start)..(evt.data?.end)}"
    removeRentalUsers((evt.data?.start)..(evt.data?.end))
}

// Remove rental users settings in the app (array of users slot numbers)
private removeRentalUsers(users) {
    def map = [] // Consolidate and remove since it's faster with the DB otherwise it times out

    users?.each { user ->
        //log.trace "Removing settings user: $user, code: $code, startDate: $startDate, startTime: $startTime, expDate: $expDate, expTime: $expTime"
        map << "userNames${user}" // name
        map << "userCodes${user}" // code
        map << "userType${user}" // type
        map << "userStartDate${user}" // start date
        map << "userExpireDate${user}" // expire date
        map << "userStartTime${user}" // start time
        map << "userExpireTime${user}" // expire time
        map << "userNotify${user}" // notifications for user
        map << "userNotifyUseCount${user}" // how many notifications for user
        map << "userLocks${user}" // user locks
        map << "userOverrideUnlockActions${user}" // custom actions
        map << "userOverrideNotifications${user}" // custom notifications
    }
    
    if (map) {
        deleteSettings(map)
    }
}

// List of supported formats and options for automatic code generation
// minAutoPinLen - number of digits in user code to generate
// phoneDigits (optional) - number of digits in phone number from reservation entries, if less than minAutoPinLen it will be padded with leading 1's
private getAutomaticCodeOptions(XXX = minAutoPinLen, phoneDigits = 0) {
    def options = [
        "phone": [ option: [ "phone": "Using phone number" ], description: (phoneDigits && (XXX > phoneDigits)) ? "The automatic user code will be ${'1'.multiply(XXX - phoneDigits)}<last ${phoneDigits} digits> of the reservation phone number" : "The automatic user code will be the last $XXX digits of the reservation phone number" ],
        "ddDDMMYY": [ option: [ "ddDDMMYY": "Using check-in/check-out date" ], description: "The automatic user code will be the first $XXX digits of 'ddDDMMYY', where 'dd' is the check-in date and 'DDMMYY' is the check-out date" ],
        "random": [ option: [ "random": "Random code" ], description: "The automatic user code will be a random $XXX digit code, unchanged for the duration of each reservation" ],
    ]
    
    return options
}

// Generic specific automatic code generation options
private getAutomaticCodeOptionsGeneric(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    return options
}

// Expedia specific automatic code generation options
private getAutomaticCodeOptionsExpedia(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    options.remove("phone") // Expedia doesn't support phone numbers
    return options
}

// TripAdvisor specific automatic code generation options
private getAutomaticCodeOptionsTripAdvisor(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    options.remove("phone") // TripAdvisor doesn't support phone numbers
    return options
}

// Booking.com specific automatic code generation options
private getAutomaticCodeOptionsBooking(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    options.remove("phone") // Booking.com doesn't support phone numbers
    return options
}

// HomeAway specific automatic code generation options
private getAutomaticCodeOptionsHomeAway(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    options.remove("phone") // HomeAway doesn't support phone numbers
    return options
}

// VRBO specific automatic code generation options
private getAutomaticCodeOptionsVRBO(XXX = minAutoPinLen) {
    def options = getAutomaticCodeOptions(XXX)
    options.remove("phone") // VRBO doesn't support phone numbers
    return options
}

// AirBnB specific automatic code generation options
private getAutomaticCodeOptionsAirBnB(XXX = minAutoPinLen, phoneDigits) {
    return getAutomaticCodeOptions(XXX, phoneDigits)
}

// Generate the automatic user code from the pattern selected using the information available
private generateAutomaticCode(autoCodePattern, pinLen, phone, startDate, expDate, name) {
    //log.trace "Automatic code: autoCodePattern:$autoCodePattern, pinLen:$pinLen, phone:$phone, startDate:$startDate, expDate:$expDate, name:$name"
    
    def code = null
    switch (autoCodePattern) {
        case "phone":
            code = (phone?.trim()?.size() >= pinLen) ? (phone?.trim()?.replaceAll(/[^0-9]/, "")?.reverse()?.take(pinLen as Integer)?.reverse() as String) : ""// Last 'pinLen' digits of phone number is the code, remove all non numbers from the phone
            break

        case "ddDDMMYY":
            code = ((startDate?.trim()?.size() >= 8) && (expDate?.trim()?.size() >= 8)) ? (startDate?.trim()?.substring(6,8) + expDate?.trim()?.substring(6,8) + expDate?.trim()?.substring(4,6) + expDate?.trim()?.substring(2,4))?.take(pinLen as Integer) as String : ""
            break
            
        case "random":
			java.security.MessageDigest md = java.security.MessageDigest.getInstance("MD5")
    		md.update(name?.trim()?.getBytes("UTF-8"))
			def uid = String.format("%032x", new BigInteger(1, md.digest())) // Convert it to a unique MD5 hash UID
    		def numCode = uid?.replaceAll(/[^0-9]/, "") // Use the numbers in the UID if present
    		code = ((numCode?.size() >= pinLen) ? numCode : (uid?.size() > pinLen ? uid?.getBytes()?.join("") : ""))?.take(pinLen) // If we don't have enough numbers, convert to ASCII
            break
            
        default:
            break
    }

    return code
}


def uninstalled() {
    log.debug "Uninstall called"
    authUpdate("uninstall")
}

def installed() {
    log.debug "Install Settings"
    authUpdate("install")
    state.sendUpdate = false
    runIn(1, appTouch) // The platform calls update after installed, so avoid a duplicate run
}

def updated() {
    log.debug "Update Settings"
    if (state.sendUpdate) {
        authUpdate("update")
        state.sendUpdate = false
    }
    runIn(1, appTouch)
}

def appTouch() {
    state.clientVersion = clientVersion() // Update our local stored client version to detect code upgrades

    unschedule() // clear all pending updates
    unsubscribe()

	if (!state.nextRentalUpdateCheck || (now() >= state.nextRentalUpdateCheck)) { // If we've never run this before then run it now or check if code was upgraded to reset, avoid iCalendar sync everytime if the app is opened in a short time which can cause VRBO to block access
        log.trace "Reset manual iCalendar sync, downloading reservation data next time the app is opened"
        state.refreshedData = false // Force a download when we open the app next
    } else {
    	log.trace "Resetting manual iCalendar sync in ${(state.nextRentalUpdateCheck - now())/60/1000} minutes"
    }
    
    // Sanity check, codes cannot be reused in the same lock (codes have to be unique to each slot)
    def allUserCodes = (1..(maxUserNames ?: 0)).collectEntries { [(it):settings."userCodes${it}"] } // Get all user codes to save db access time
    for (int i = 1; i <= maxUserNames; i++) {
        def code1 = allUserCodes[i]
        if (maxManualUsers && (i <= maxManualUsers)) { // Only applied to manual users, multiple automatic users don't work on the same day so there no conflict if the same users have multiple schedules
            getDuplicateCodeUsers(allUserCodes, i).each { j ->
                def name1 = settings."userNames${i}"
                def name2 = settings."userNames${j}"
                def code2 = allUserCodes[j]
                def msg = "CHANGE CODE - USER $name1 IN SLOT $i and USER $name2 IN SLOT $j SHARE THE SAME CODE $code1"
                log.error msg
                sendNotifications(msg)
            }
        }

        // Check if the user has entered a non digit string
        if ((code1?.size() > 0) && !code1?.isNumber()) {
            def name1 = settings."userNames${i}"
            def msg = "CODE IS NOT A NUMBER, PROGRAMMING WILL FAIL - USER $name1 IN SLOT $i DOES NOT CONTAIN A NUMERIC PIN"
            log.error msg
            sendNotifications(msg)            
        }
        
        // Check if the lock pin code length match the pin code length entered by the user
        def userLocks = (locks?.size() > 1) ? (settings."userLocks${i}" ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
        for (lock in locks) {
            def codeLen = (lock.currentValue("codeLength") ?: (lock.currentValue("pinLength") ?: null)) as Integer
            def maxCodeLen = (lock.currentValue("maxCodeLength") ?: (lock.currentValue("maxPINLength") ?: null)) as Integer
            def minCodeLen = (lock.currentValue("minCodeLength") ?: (lock.currentValue("minPINLength") ?: null)) as Integer
            if (userLocks?.contains(lock.id) && (codeLen || (maxCodeLen && minCodeLen))) { // Check if the lock support reporting pin length and it has a valid number to report (not 0 or null)
                if ((code1?.size() > 0) && (codeLen ? codeLen != code1.size() : ((code1.size() < minCodeLen) || (code1.size() > maxCodeLen)))) { // If we have a code to program
                    def name1 = settings."userNames${i}"
                    def msg = "CODE LENGTH DOES NOT MATCH $lock PROGRAMMING LENGTH, PROGRAMMING WILL FAIL - USER $name1 IN SLOT $i REQUIRES ${codeLen ?: "${minCodeLen}-${maxCodeLen}"} DIGITS FOR LOCK ${lock}"
                    log.error msg
                    sendNotifications(msg)
                }
            }
        }
    }

    // Initialize when we are going to check for code version updates
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }
    def random = new Random()
    Integer randomHour = random.nextInt(18-10) + 10
    Calendar localCalendar = Calendar.getInstance(timeZone)
    localCalendar.set(Calendar.DAY_OF_WEEK, (new Date(now()))[Calendar.DAY_OF_WEEK]) // Starting today
    localCalendar.set(Calendar.HOUR_OF_DAY, randomHour) // Check for code updates everyday at a random time between 10am and 6pm
    localCalendar.set(Calendar.MINUTE, 3) // Offset to avoid ST platform timeout issue at top of hour
    localCalendar.set(Calendar.SECOND, 0)
    localCalendar.set(Calendar.MILLISECOND, 0)
    if (localCalendar.getTimeInMillis() < now()) { // If it's in the past add one day to it
        localCalendar.add(Calendar.DAY_OF_YEAR, 1)
    }
    state.nextCodeUpdateCheck = state.nextCodeUpdateCheck ?: localCalendar.getTimeInMillis() // If it's already set then don't update it
    log.debug "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    
    // subscribe to events to kick start timers and presence/mode events to update code states
    subscribe(location, "mode", changeHandler)
    subscribe(app, changeHandler) // Capture user intent to reinitialize timers
    def presence = []// subscribe to presence
    for (int i = 1; i <= maxUserNames; i++) {
		if (settings."userType${i}" == "Presence") {
        	presence = (presence + (settings."userPresent${i}" ?: []) + (settings."userNotPresent${i}" ?: [])).unique()
        }
    }
    log.trace "Subscribing to people: $presence"
    subscribe(presence, "presence", changeHandler)

    subscribe(locks, "lock", lockHandler) // Subscribe to lock events to take action as defined as user
    subscribe(locks, "tamper", lockHandler) // Subscribe to tamper events
    subscribe(locks, "codeReport", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful
    subscribe(locks, "codeChanged", codeResponse, [filterEvents:false]) // Subscribe to code report events to see if the code update was successful
    //subscribe(location, "alarmSystemStatus" , shmChangeHandler) // Subscribe to SHM state handler
    /*if (adtDevices) {
        subscribe(adtDevices, "securitySystemStatus" , adtChangeHandler) // Subscribe to ADT state handler
    }*/

    // Reset the code update trackers and heartbeat system
    state.lastCheck = 0
    state.lastHeartBeat = 0

    locks.each { lock -> // check each lock individually
        if (settings."sensor${lock}") {
            log.trace "Subscribing to sensor ${settings."sensor${lock}"} for ${lock}"
            subscribe(settings."sensor${lock}", "contact", sensorHandler)
        }
        if (lock.hasAttribute('invalidCode')) {
            log.trace "Found attribute 'invalidCode' on $lock, enabled support for invalid code detection"
            subscribe(lock, "invalidCode", lockHandler)
        }
    }

    // Initialize if not initialized already
    state.phonePattern = state.phonePattern ?: [:]
    state.checkInNextRun = state.checkInNextRun ?: [:]
    state.checkInLastRun = state.checkInLastRun ?: [:]
    state.checkOutNextRun = state.checkOutNextRun ?: [:]
    state.checkOutLastRun = state.checkOutLastRun ?: [:]
    state.updatedUsers = state.updatedUsers ?: []
    state.sentSMS = state.sentSMS ?: [] // Track SMS that were sent, initialize if not initialized

    state.invalidUsers = [] // Track notifications for invalid users, always reset on initialization
    state.usedOneTimeCodes = [:]
    state.trackUsedOneTimeCodes = [] // Track for reporting purposes
    state.retryCodeCount = [:] // Number of times a code programming has been retried
    state.codeUseCount = [:] // Number of times codes were used
    if (!state.lockCodes) {
        state.lockCodes = [:] // Save list of programmed codes, initialize only if not already done
    }
    state.expiredLockList = []
    atomicState.reLocks = [:] // List of lock to relock after a timed delay
    atomicState.notifyOpenDoors = [:] // List of locks to check for open notifications
    atomicState.immediateLocks = [] // List of lock to lock immediately after a short delay
    atomicState.unLocks = [] // List of lock to unlock after a short delay
    for (lock in locks) {
        state.codeUseCount[lock.id] = [:] // Number of times a code usage was used for this lock
        state.usedOneTimeCodes[lock.id] = [] // List of used one time codes for this lock
        state.retryCodeCount[lock.id] = [:] // Number of times a code programming has been retried for the lock
        if (!state.lockCodes[lock.id]) {
            state.lockCodes[lock.id] = [:] /// Track programmed codes for this lock, initialize only if not already done
        }
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed with expired
        //log.trace "Added $lock id ${lock.id} to expire list ${state.expiredLockList}"
    }
    state.lockCodes.each { lockID, userMap ->
        if (!locks?.any { lock -> lock.id == lockID }) {
            log.debug "Lock with ID ${lockID} is no longer being programmed, stop tracking users from the lock"
            state.lockCodes[lockID] = [:] /// Stop tracking codes from this lock once we exclude the lock from our main list
        }
    }        
    state.expiredNextCode = 1 // set next code to be set for the expired loop

    log.trace "Install complete"

    if (clearUserCodes) {
        clearAllCodes()
    } else {
        runIn(1, kickStart) // Initialize codes
    }
}

// Handle changes, reinitialize the code check timers after a change, this is to workaround the issue of a buggy ST platform where the timers die randomly for some users
def changeHandler(evt) {
    log.trace "Reinitializing code check timer on event notification, name: ${evt?.name}, value: ${evt?.value}, device: ${evt?.device}"
    
    if (evt?.name == "mode") { // Mode change notification
        for (lock in locks) { // Check all locks
            def sensor = settings."sensor${lock}" // Find the lock for this sensor, match by ID and not objects
            if (sensor) {
                log.trace "Checking for any pending door sensor activites that need to be done for lock $lock with sensor $sensor in mode ${evt.value}"
                def sensorEvt = [name: sensor.name, displayName: sensor.displayName, value: sensor.latestValue("contact"), device: sensor]
                sensorHandler(sensorEvt)
            }
        }
    }
    
    if (evt?.name == "presence") { // User arrives/leaves
        log.trace "Checking for presence ${evt?.device} actions"
        def msgs = [:]
        for (int i = 1; i <= maxUserNames; i++) {
            def code = settings."userCodes${i}" as String
            def type = settings."userType${i}"
            def userPresent = settings."userPresent${i}"
            def userNotPresent = settings."userNotPresent${i}"
            def presenceLock = settings."userPresenceLock${i}"
            def presenceUnlock = settings."userPresenceUnlock${i}"
            if ((code != null) && (type == "Presence") && (presenceLock || presenceUnlock) && ((userPresent?.any { evt?.device?.id == it.id }) || (userNotPresent?.any { evt?.device?.id == it.id }))) { // Find all programmed users controlled by presence and need to lock/unlock on presence
                def userLocks = (locks?.size() > 1) ? (settings."userLocks${i}" ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
                def name = settings."userNames${i}" // Get the name for the slot
                def doAdd = false
                // Any of the 'present' users AND none of the 'not present' users are there then the code is active so unlock OR lock as required
                if ((userPresent ? userPresent.any{it.currentPresence == "present"} : true) &&
                    (userNotPresent ? userNotPresent.every{it.currentPresence != "present"} : true)
                   ) {
                    doAdd = true
                } else {
                    doAdd = false
                }
                
                for (lock in locks) {
                    if (userLocks.contains(lock.id)) {
                        if (!doAdd && presenceLock) {
                            def msg = "Locking ${lock} for user ${name} because ${evt.device.displayName} ${evt.value == "present" ? "arrived" : "left"}"
                            if (lock.currentValue("lock") != "locked") {
                                log.info msg
                                msgs += [ "${msg}" : (settings."userOverrideNotifications${i}" && settings."userNotify${i}") ? i as String : "" ] // TODO: For now ALWAYS notify if locking/unlocking for security reasons, can use custom notifications settings
                                lock.lock()
                            } else {
                                log.debug "${lock} already locked, skipping ${msg}"
                            }
                        } else if (doAdd && presenceUnlock) {
                            def msg = "Unlocking ${lock} for user ${name} because ${evt.device.displayName} ${evt.value == "present" ? "arrived" : "left"}"
                            if (lock.currentValue("lock") != "unlocked") {
                                log.info msg
                                msgs += [ "${msg}" : (settings."userOverrideNotifications${i}" && settings."userNotify${i}") ? i as String : "" ] // TODO: For now ALWAYS notify if locking/unlocking for security reasons, can use custom notifications settings
                                lock.unlock()
                            } else {
                                log.debug "${lock} already unlocked, skipping ${msg}"
                            }
                        }
                    }
                }
            }
        }
        // Last thing to do because it can timeout
        msgs.each { msg, user ->
            sendNotifications(msg, user)
        }
    }

    if (evt?.value == "touch") { // App touch notification
        downloadRentalData()
    }

    // Do a code check and restart the scheduler if required
    // Reset the lock list and start from 1st code in first lock and check all codes
    state.expiredLockList = []
    state.expiredNextCode = 1 // reset back to 1 for the next lock
    for (lock in locks) {
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed
        //log.trace "Added $lock id ${lock.id} back to unprocessed locks list ${state.expiredLockList}"
    }
    
    kickStart()
}

// Handle changes to ADT states
def adtChangeHandler(evt) {
    log.trace "ADT state change notification, name: ${evt?.name}, value: ${evt?.value}"

    def msg = ""
    def keypads = locks?.findAll{ it.hasAttribute("armMode") } // Get all keypads and sync state with ADT
    // We don't check for individual user custom actions for keypads since synchronization needs to happen at the keypad level
    keypads = (settings."individualDoorActions${""}" ? keypads.findAll { keypad -> (settings."keypadArmDisarm${keypad}${""}") } : (settings."keypadArmDisarm${""}${""}" ? keypads : null)) // Get keypads with direct control enabled
    def mode = settings."adtDevices"?.currentState("securitySystemStatus")?.value // This should the new ADT state
    if (keypads) {
        switch (mode) {
            case "armedAway":
                msg = "Detected ADT mode change, setting $keypads to Armed Away"
                keypads*.setArmedAway()
                break	

            case "armedStay":
                msg = "Detected ADT mode change, setting $keypads to Armed Stay"
                keypads*.setArmedStay()
                break

            case "disarmed":
                msg = "Detected ADT mode change, setting $keypads to Disarmed"
                keypads*.setDisarmed()
                break

            default:
                log.error "Unknown ADT mode $mode"
                break
        }
    } else {
        log.trace "No keypads found under direct ADT control"
    }
    
    if (keypads && msg) {
        log.info msg
    }
}

// Handle changes to SHM states
def shmChangeHandler(evt) {
    log.trace "SHM state change notification, name: ${evt?.name}, value: ${evt?.value}"

    def msg = ""
    def keypads = locks?.findAll{ it.hasAttribute("armMode") } // Get all keypads and sync state with SHM
    // We don't check for individual user custom actions for keypads since synchronization needs to happen at the keypad level
    keypads = (settings."individualDoorActions${""}" ? keypads.findAll { keypad -> (settings."keypadArmDisarm${keypad}${""}") } : (settings."keypadArmDisarm${""}${""}" ? keypads : null)) // Get keypads with direct control enabled
    def mode = location.currentState("alarmSystemStatus")?.value // This should the new SHM state
    if (keypads) {
        switch (mode) {
            case "away":
                msg = "Detected SHM mode change, setting $keypads to Armed Away"
                keypads*.setArmedAway()
                break	

            case "stay":
                msg = "Detected SHM mode change, setting $keypads to Armed Stay"
                keypads*.setArmedStay()
                break

            case "off":
                msg = "Detected SHM mode change, setting $keypads to Disarmed"
                keypads*.setDisarmed()
                break

            default:
                log.error "Unknown SHM mode $mode"
                break
        }
    } else {
        log.trace "No keypads found under direct SHM control"
    }
    
    if (keypads && msg) {
        log.info msg
    }
}

def sensorHandler(evt) {
    log.trace "Event name $evt.name, value $evt.value, device $evt.displayName"

    def sensor = evt.device

    def lock = locks.find { settings."sensor${it}"?.id == sensor.id } // Find the lock for this sensor, match by ID and not objects
    log.trace "Sensor ${sensor} belongs to Lock ${lock}"

    if (evt.value == "closed") { // Door was closed
        if (lock && settings."relockDoor${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
                log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
            } else {
                if (settings."relockImmediate${lock}") {
                    log.debug "Relocking ${lock} immediately in 3 seconds"
                    def immediatelocks = atomicState.immediateLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    if (!immediatelocks.contains(lock.id)) { // Don't re add the same lock again
                        //log.trace "Adding ${lock.id} to the list of immediate locks"
                        immediatelocks.add(lock.id) // Atomic to ensure we get upto date info here
                        atomicState.immediateLocks = immediatelocks // Set it back, we can't work direct on atomicState
                    }
                    immediateLockDoor() // Lock it right away
                } else if (settings."relockAfter${lock}") {
                    log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
                    def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    //log.trace "Adding ${lock.id} to the list of relocks"
                    reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                    atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
                    reLockDoor() // Call relock door it'll take of delaying the lock as required
                } else {
                    log.error "Invalid configuration, no relock timeout defined"
                }
            }
        }
    } else { // Door was opened
        // Chime bell
        if (settings."openNotifyBeep${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Door ${sensor} was opened, chiming bell ${settings."openNotifyBeep${lock}"}"
                settings."openNotifyBeep${lock}".beep() // Beep
            } else {
                log.trace "${lock} chiming not set for Mode ${location.mode}"
            }
        }

        // Notify user
        if (settings."openNotify${lock}") {
            if (!settings."openNotifyModes${lock}" || (settings."openNotifyModes${lock}"?.find{it == location.mode})) {
                log.debug "Scheduling ${lock} to notify user of open door in ${settings."openNotifyTimeout${lock}"} minutes"
                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
                atomicState.notifyOpenDoors = notifyOpenDoors // Set it back, we can't work direct on atomicState
                notifyOpenDoor() // Notify, it'll take of delaying it if it's too soon
            } else {
                log.trace "${lock} open notification not set for Mode ${location.mode}"
            }
        }
    }
}

// Check for any pending door unlocks
def unLockDoor() {
    def unLocksIDs = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending door unlocks ${unLocksIDs}"

    unLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "UnLocking the door ${lock} immediately"
        lock.unlock() // unlock it
        def unlocks = atomicState.unLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending unlocks"
        unlocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.unLocks = unlocks // set it back to atomicState
        //log.trace "Checking for any pending door unlocks in 3 seconds"
        startTimer(3, unLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending immediate door locks
def immediateLockDoor() {
    def immediateLocksIDs = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Pending immediate door locks ${immediateLocksIDs}"

    immediateLocksIDs?.each { lockid ->
        def lock = locks.find { it.id == lockid } // find the lock
        log.info "Locking the door ${lock} immediately"
        lock.lock() // lock it
        def immediatelocks = atomicState.immediateLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
        //log.trace "Removing ${lockid} from the list of pending immediate locks"
        immediatelocks.remove(lockid) // We are done with this lock, remove it from the list
        atomicState.immediateLocks = immediatelocks // set it back to atomicState
        //log.trace "Checking for any pending immediate door locks in 3 seconds"
        startTimer(3, immediateLockDoor) // Next immediate door lock in 3 seconds (give it some time for the mesh network)
        return // We're done here
    }
}

// Check for any pending delayed door relocks
def reLockDoor() {
    def reLocksIDs = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking door sensor state and relocking ${reLocksIDs}"

    Long shortestPendingTime = 0 // in seconds
    
    reLocksIDs?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock

        if (!settings."relockAfter${lock}") { // Check if the settings have changed
            log.trace "No relock timeout specified for door ${lock} as settings/modes have changed"
            //log.trace "Removing ${lockid} from the list of pending relocks"
            def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            reLocks.remove(lockid) // We are done with this lock, remove it from the list
            atomicState.reLocks = reLocks // set it back to atomicState
            return // move on
        }
        
        Long timeLeft = (((60 * 1000 * settings."relockAfter${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true) { // Check if the mode is still active
                if (!lockSensor) { // If we don't have a sensor then just lock on schedule
                    log.info "No sensor found on ${lock} when closed, locking the door"
                    lock.lock() // lock it
                    //log.trace "Removing ${lockid} from the list of pending relocks"
                    def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    reLocks.remove(lockid) // We are done with this lock, remove it from the list
                    atomicState.reLocks = reLocks // set it back to atomicState
                    //log.trace "Checking for any pending relocks in 3 seconds"
                    startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                    return // We're done here
                } else if (lockSensor.latestValue("contact") == "closed") {
                    log.info "Sensor ${lockSensor} is reporting door ${lock} is closed, locking the door"
                    lock.lock() // lock it
                    //log.trace "Removing ${lockid} from the list of pending relocks"
                    def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                    reLocks.remove(lockid) // We are done with this lock, remove it from the list
                    atomicState.reLocks = reLocks // set it back to atomicState
                    //log.trace "Checking for any pending relocks in 3 seconds"
                    startTimer(3, reLockDoor) // Next pending relock in 3 seconds (give it some time for the mesh network)
                    return // We're done here
                } else {
                    log.debug "Sensor ${lockSensor} is reporting door ${lock} is not closed, will check again in 60 seconds"
                    startTimer(60, reLockDoor) // Check back again in some time
                }
            } else {
                log.trace "Relock mode conditions not met, not executing relock"
                def reLocks = atomicState.reLocks // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                reLocks.remove(lockid) // We are done with this lock, remove it from the list
                atomicState.reLocks = reLocks // set it back to atomicState
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."relockAfter${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), reLockDoor) // Check back again after shortest pending timeout
    }
}

// Notify if the doors are left open
def notifyOpenDoor() {
    def notifyOpenDoorsIds = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
    log.trace "Checking Locks ${notifyOpenDoorsIds} door sensor state"

    Long shortestPendingTime = 0 // in seconds
    
    notifyOpenDoorsIds?.each { lockid, timestamp ->
        def lock = locks.find { it.id == lockid } // find the lock
        def lockSensor = settings."sensor${lock}" // Get the sensor for the lock
        
        if (!settings."openNotify${lock}" || !settings."openNotifyTimeout${lock}" || (settings."openNotifyModes${lock}" && !(settings."openNotifyModes${lock}"?.find{it == location.mode}))) { // Check if the settings have changed
            log.trace "No need to monitor open sensor ${lockSensor} for door ${lock} as settings/modes have changed"
            //log.trace "Removing ${lockid} from the list of pending notifications"
            def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
            atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            return // move on
        }
        
        Long timeLeft = (((60 * 1000 * settings."openNotifyTimeout${lock}") + timestamp) - now())/1000 // timestamp and now() is in ms
        if (timeLeft <= 1) { // If we are within 1 second then go ahead since the timer isn't always 100% accurate
            if (lockSensor.latestValue("contact") == "closed") {
                log.trace "Sensor ${lockSensor} is reporting door ${lock} is closed, no notification required"
                //log.trace "Removing ${lockid} from the list of pending notifications"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState
            } else {
                log.info "Sensor ${lockSensor} is reporting door ${lock} is open, notifying user${settings."openNotifyRepeat${lock}" ? " and checking again after ${settings."openNotifyTimeout${lock}"} minutes" : ""}"
                def msg = "$lockSensor has been open for ${settings."openNotifyTimeout${lock}"} minutes"

                //log.trace "Updating ${lock.id} timestamp in the list of notifyOpenDoors"
                def notifyOpenDoors = atomicState.notifyOpenDoors // We need to deference the atomicState object each time, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (settings."openNotifyRepeat${lock}") {
                    notifyOpenDoors[lock.id] = now() // Atomic to ensure we get upto date info here
                } else {
                    notifyOpenDoors.remove(lock.id) // We are done with this lock, remove it from the list
                }
                atomicState.notifyOpenDoors = notifyOpenDoors // set it back to atomicState

                if (settings."openNotifyRepeat${lock}") {
                    startTimer(60, notifyOpenDoor) // Check back again after short timeout so we don't overwrite a short wait with a long wait
                }
                sendNotifications(msg) // Do it in the end to avoid a timeout
            }
        } else {
            log.trace "${lock} has not reached the time limit of ${settings."openNotifyTimeout${lock}"} minutes yet, ${timeLeft/60} minutes to go"
            if (!shortestPendingTime || (timeLeft < shortestPendingTime)) {
                log.trace "Settings shortest pending time to ${timeLeft} seconds"
                shortestPendingTime = timeLeft
            }
        }
    }
    
    if (shortestPendingTime) {
        startTimer((shortestPendingTime < 1 ? 1 : shortestPendingTime), notifyOpenDoor) // Check back again after shortest pending timeout
    }
}

def codeResponse(evt) {
    def lock = evt.device
    def user = evt.value?.isInteger() ? evt.value as Integer : null
    def type = null
    if (!user) { // For new handler codeChanged doesn't report the user slot, we need to extract it (we only subscribe to codeChanged and codeReport)
    	def value = evt.value?.split(" ")?.first()?.trim()
        user = value?.isInteger() ? value as Integer : null
        if (evt.value?.split(" ")?.size() > 1) {
            type = evt.value?.split(" ")?.last()?.trim() // Get the transaction type
        }
    }
    def code = evt.data ? parseJson(evt.data)?.code : "" // Not all locks return a code due to a bug in the base Z-Wave lock device code
    def desc = evt.descriptionText // Description can have "is set" or "was added" or "changed" when code was added successfully
    def name = settings."userNames${user}"

    log.trace "$lock code report ${evt.name} returned Name:${name ?: ""}, User:${user}, Code:${code}, Desc:${desc}, Value: ${evt.value}, Type: ${type}"
    
    if ((evt.name == "codeChanged") && (evt.value == "all deleted" || evt.value == "all")) { // Special case, when lock is reset all codes are deleted, we don't have a user id for this one
        // First update tracking lists for used one time codes - to avoid a race condition with programmed codes
        state.usedOneTimeCodes[lock.id] = [] // Reset list as all codes are deleted
        state.codeUseCount[lock.id] = [:] // Reset code usage count
        state.lockCodes[lock.id] = [:] // Reset list
        state.retryCodeCount[lock.id] = [:] // Reset list
        def msg = "All user codes were deleted from $lock"
        log.info msg
        sendNotifications(msg) // This is mandatory as a special exception
        return // We're done here
    } else if (!user) {
        log.warn "No user slot/id found in code reponse from lock, ignoring report"
        return // We're done here
    }

    switch (type) { // For new device handler we already have a type and so lets use it
        case "set":
        case "changed":
        	type = "added" // Update the type
            break
            
        case "deleted":
        case "unset":
        	type = "deleted"
            break
            
        case "failed":
        	if (desc?.contains("duplicate")) { // DTH inaccurately reports some failed programming codes as duplicate so check extended event for real reason
                type = "duplicate"
            } // If a previous code reponse notification was lost it will report failed, but don't try to add it because a genuine failure cannot be captures. This is an issue to lock communication with z-wave mesh which needs to be addressed
            break
            
        case "renamed":
        	type = "renamed"
            break
            
        case null: // This is if we are using the device handlers which use codeReport
            if (evt.name == "codeReport") {
                if ((["is set", "added", "changed"].any { desc?.contains(it) }) && !(["unset"].any { desc?.contains(it) })) { // Bug with new ST handler uses the words changed and unset in CodeChanged event
                    type = "added"
                } else if (["is not set", "deleted"].any { desc?.contains(it) }) {
                    type = "deleted"
                } else if (["duplicate"].any { desc?.contains(it) }) {
                    type = "duplicate"
                }
            }
            break
            
        default:
            log.warn "Ignoring transaction from $lock for user $user: ${desc}"
	        return // We're done here
            break
    }
    
    if (!type) {
        log.warn "Ignoring transaction from $lock for user $user: ${desc}"
        return // We're done here
    }
    
    def currentCode = settings."userCodes${user}" as String

    // Failed means lock cannot add code for multiple reasons, like wrong pin length or it's a duplicate (either from another slot or because the prior add confirmation was lost we didn't know)
    // Do don't assume it's done and add back because the DTH can't tell the differnce between duplicates and lost responses or bad lengths
    if (!(state.lockCodes[lock.id].(user as String)) && (type == "failed")) { // Only process duplicate code notitications if the user is not already programmed in our list
        def msg = "$lock failed to add user $user. Retrying again, check pin length or try to change the code"
        log.warn msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg) // It can fail if the user was added by other means, so we only report if needed
        return // We're done here
    }
    
    if (!(state.lockCodes[lock.id].(user as String)) && (type == "duplicate")) { // Only process duplicate code notitications if the user is not already programmed in our list
        def msg = "$lock reported user $user is a duplicate code! Please clear extra codes from your lock"
        log.warn msg
        sendNotifications(msg) // This is mandatory, cannot ignore
        return // We're done here
    }
    
    if ((state.lockCodes[lock.id].(user as String)) && (type == "renamed")) { // Only rename slots that we have in our list
        def newName = desc?.split('" to "')?.last()?.replace('"', '') // Get new name and remove quotes
        if (newName && (newName != name)) { // Cannot be blank and should be different
            updateSetting("userNames${user}", newName)
            def msg = "$lock renamed user $user from $name to $newName"
            log.info msg
            detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        }
        return // We're done here
    }
    
    if ((!state.lockCodes[lock.id].(user as String) || (state.lockCodes[lock.id].(user as String) != currentCode)) && (type == "added")) { // We can get the notifications multiple times
        state.lockCodes[lock.id][user as String] = currentCode ?: "1" // If the code doesn't exist then someone added the code externally, mark it a special code so it'll be deleted
        state.retryCodeCount[lock.id][user as String] = 0 // Reset the retry
        def msg = "Confirmed $lock added $name to user $user"
        log.info msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        return // We're done here
    }

    if ((state.lockCodes[lock.id].(user as String)) && (type == "deleted")) { // We can get the notifications multiple times (don't track "was reset" as that's an intermediary notification while setting a code)
        // First update tracking lists for used one time codes - to avoid a race condition with programmed codes
        if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
            state.usedOneTimeCodes[lock.id].remove(user as String)
            log.trace "Deleted code was a used one time code, removing it from list of used one time codes"
        }
        state.codeUseCount[lock.id].remove(user as String) // Don't track the usage for this code anymore
        state.lockCodes[lock.id].remove(user as String)
        state.retryCodeCount[lock.id][user as String] = 0 // Reset the retry
        def msg = "Confirmed ${name ?: ""} user $user was deleted from $lock"
        log.info msg
        detailedNotifications ? sendNotifications(msg) : sendNotificationEvent(msg)
        return // We're done here
    }
}

// Lock event handler
def lockHandler(evt) {
    def data = null
    def lock = evt.device
    
    log.trace "Lock event name $evt.name, value $evt.value, device $evt.displayName, description $evt.descriptionText, data $evt.data"

    def evtMap = [name:evt.name, value:evt.value, displayName:evt.displayName, descriptionText:evt.descriptionText, data:evt.data, lockId: evt.device.id] // NOTE: Bug with ST, runIn passes a JSONObject instead of a map - https://community.smartthings.com/t/runin-json-vs-map/104442 so convert evt to a standard map and also we can't pass evt object to runIn

    if (evt.name == "lock") { // LOCK UNLOCK EVENTS
        if (evt.value == "unlocked") { // UNLOCKED
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processUnlockEvent(evtMap)
        } else if (evt.value == "locked") { // LOCKED MANUALLY OR VIA KEYPAD OR ELECTRONICALLY
            unschedule(processLockActions) // If there was a pending delayed actions and user operated the lock then cancel it
            processLockEvent(evtMap)
        } else if (evt.value == "unknown") { // JAMMED CODE EVENT
            log.debug "Lock $evt.displayName Jammed!"
            if ((!settings."individualDoorActions" && jamNotify) ||
                (settings."individualDoorActions" && settings."jamNotify${lock}")) {
                def msg = "$evt.displayName lock is Jammed!"
                sendNotifications(msg)
            }        	
        }
    } else if (evt.name == "invalidCode") { // INVALID LOCK CODE EVENT
        log.debug "Lock $evt.displayName, invalid user code: ${evt.value}"
        def msg = "Invalid user code detected on $evt.displayName"
        sendNotifications(msg)
    } else if (evt.name == "tamper" && evt.value == "detected") { // Tampering of the lock
        log.debug "Lock $evt.displayName tamper detected with description $evt.descriptionText"
        def msg = "Tampering detected on $evt.displayName. ${evt.descriptionText ?: ""}"
        sendNotifications(msg)
    }
}

def processUnlockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

	log.trace "Processing $lock unlock event: $evt"

    // Check if we have delayed relock is enabled, if so then start the timer now just incase the user never opens the door (reLockDoor will take care of sensor if present, immediate relock should never happen without a sensor)
    if (settings."relockDoor${lock}" && settings."relockAfter${lock}" && (settings."relockDoorModes${lock}" ? settings."relockDoorModes${lock}".find{it == location.mode} : true)) { // Are we asked to reLock this door
        if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) {
            log.warn "Disable AutoLock on physical lock to use SmartApp AutoReLock and AutoUnlock features"
        } else {
            log.debug "Scheduling ${lock} to lock in ${settings."relockAfter${lock}"} minutes"
            def reLocks = atomicState.reLocks ?: [:] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
            //log.trace "Adding ${lock.id} to the list of relocks"
            reLocks[lock.id] = now() // Atomic to ensure we get upto date info here, Update and Add work the same way here so we don't need to check before adding/updating
            atomicState.reLocks = reLocks // Set it back, we can't work direct on atomicState
            reLockDoor() // Call relock door it'll take of delaying the lock as required
        }
    } else {
        log.trace "Relock conditions not met, not scheduling relock"
    }

    if (evt.data) { // Was it unlocked using a code
        data = parseJson(evt.data)
    }
    
    def user = (data?.usedCode as String) ?: ((data?.codeId as String) ?: "") // get the user if present
    def i = ((data?.usedCode ?: 0) as Integer) ?: (((data?.codeId ?: 0) as Integer) ?: 0) // get the user if present
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    if (!user && !(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) { // No extended data, must be a manual/auto/keyed unlock, NOTE: some locks don't send keypad user codes
        log.trace "$evt.displayName was unlocked manually. Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            def msg = "$evt.displayName was unlocked $lockMode"

            /*if (settings."homeDisarmManual${lockStr}") { // Sync SHM
                log.info "Disarming Smart Home Monitor"
                sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
            }*/
            
            /*try {
                if (settings."adtDisarmManual${lockStr}" && settings."adtDevices") {
                    log.info "Disarming ADT"
                    settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                    msg += detailedNotifications ? ", disarming ADT" : ""
                }
            } catch (e) { // This is still not official so lets be cautious about it
                log.error "Error disarming ADT\n$e"
                msg += ", error disarming ADT"
            }*/

            if (settings."homeModeManual${lockStr}") {
                log.info "Changing mode to ${settings."homeModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."homeModeManual${lockStr}"}) {
                    setLocationMode(settings."homeModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeModeManual${lockStr}"}" : ""
            }

            /*if (settings."homePhraseManual${lockStr}" && location.helloHome?.getPhrases()) {
                log.info "$evt.displayName was unlocked successfully, running routine ${settings."homePhraseManual${lockStr}"}"
                location.helloHome.execute(settings."homePhraseManual${lockStr}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhraseManual${lockStr}"}" : ""
            }*/

            if (settings."turnOnSwitchesAfterSunsetManual${lockStr}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunsetManual${lockStr}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunsetManual${lockStr}"}" : ""
                }
            }

            if (settings."turnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitchesManual${lockStr}"}"
                settings."turnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."turnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitchesManual${lockStr}"}"
                settings."turnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."unlockLocksManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocksManual${lockStr}"}"
                settings."unlockLocksManual${lockStr}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocksManual${lockStr}"}" : ""
            }

            if (settings."openGarageManual${lockStr}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarageManual${lockStr}"}"
                settings."openGarageManual${lockStr}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarageManual${lockStr}"}" : ""
            }

            if (settings."manualNotify${lockStr}" && (settings."manualNotifyModes${lockStr}" ? settings."manualNotifyModes${lockStr}".find{it == location.mode} : true)) {
                sendNotifications(msg)
            }
        }
    } else { // KEYPAD / RFID UNLOCK
        def name = settings."userNames${i}"
        def notify = settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : false // UpdateSettings stores it as string
        def notifyCount = settings."userNotifyUseCount${i}" ? (settings."userNotifyUseCount${i}" as Integer) : 0 // UpdateSettings stores as string
        def notifyModes = settings."userNotifyModes${i}"
        def notifyXPresence = settings."userXNotifyPresence${i}"

        log.trace "Lock $evt.displayName unlocked by $name, notify $notify, notify count: $notifyCount, notify modes $notifyModes, notify NOT present $notifyXPresence, Source type: $lockMode"

        def msg = ""

        if (i == 0) {
            name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
            notify = true // always inform about master users
            user = "" // Master code uses general actions
        }

        if (!name) { // will handle usedCode null errors
            notify = true // always inform about unknown users
            msg = "$evt.displayName was unlocked by Unknown User from slot $i $lockMode"
        } else {
            msg = "$evt.displayName was unlocked by $name $lockMode"
        }

        // Check if we have user override unlock actions defined
        if (!settings."userOverrideUnlockActions${i as String}") {
            log.trace "Did not find per user unlock actions, falling back to general actions"
            user = ""
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // First disarm SHM since it goes off due to other events
        if (settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleUnlockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running unlock actions for door $lock"
        } else if (settings."runXModeUnlockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running unlock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
            if ((settings."keypadArmDisarm${lockStr}${user}") && data?.armMode) {
                switch (data.armMode) { // Set Keypad lock state
                    case "disarmed":
                    	/*log.info "Disarming Smart Home Monitor" // Sync SHM
                    	sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                        msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""*/
                        /*try {
                            if (settings."adtDevices") {
                                log.info "Disarming ADT"
                                settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                                msg += detailedNotifications ? ", disarming ADT" : ""
                                startTimer(1, adtChangeHandler) // If this came from a keypad and direct control for ADT is enabled, then refresh the keypad state (incase exit code beeping needs to be cancelled)
                            //} else {
                            //    startTimer(1, shmChangeHandler) // If this came from a keypad and direct control for SHM is enabled, then refresh the keypad state (incase exit code beeping needs to be cancelled)
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error disarming ADT\n$e"
                            msg += ", error disarming ADT"
                        }*/
                    	break
                        
                    default:
                        log.warn "Invalid keypad mode detected: ${data.armMode}"
                        msg += ", invalid keypad mode ${data.armMode}"
                        break
                }
            } else {
                /*if (settings."homeDisarm${lockStr}${user}") { // Sync SHM
                    log.info "Disarming Smart Home Monitor"
                    sendLocationEvent(name: "alarmSystemStatus", value: "off") // First do this to avoid false alerts from a slow platform
                    msg += detailedNotifications ? ", disarming Smart Home Monitor" : ""
                }*/
                
                /*try {
                    if (settings."adtDisarm${lockStr}${user}" && settings."adtDevices") {
                        log.info "Disarming ADT"
                        settings."adtDevices"?.disarm() // First do this to avoid false alerts from a slow platform
                        msg += detailedNotifications ? ", disarming ADT" : ""
                    }
                } catch (e) { // This is still not official so lets be cautious about it
                    log.error "Error disarming ADT\n$e"
                    msg += ", error disarming ADT"
                }*/
            }

            if (settings."homeMode${lockStr}${user}") {
                log.info "Changing mode to ${settings."homeMode${lockStr}${user}"}"
                if (location.modes?.find{it.name == settings."homeMode${lockStr}${user}"}) {
                    setLocationMode(settings."homeMode${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."homeMode${lockStr}${user}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."homeMode${lockStr}${user}"}" : ""
            }

            /*if (settings."homePhrase${lockStr}${user}" && location.helloHome?.getPhrases()) {
                log.info "$evt.displayName was unlocked successfully, running routine ${settings."homePhrase${lockStr}${user}"}"
                location.helloHome.execute(settings."homePhrase${lockStr}${user}") // First do this to avoid false alerts from a slow platform
                msg += detailedNotifications ? ", running routine ${settings."homePhrase${lockStr}${user}"}" : ""
            }*/

            if (settings."turnOnSwitchesAfterSunset${lockStr}${user}") {
                def cdt = new Date(now())
                def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                    log.info "$evt.displayName was unlocked successfully, turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"} since it's after sunset but before sunrise"
                    settings."turnOnSwitchesAfterSunset${lockStr}${user}"?.on()
                    msg += detailedNotifications ? ", turning on lights ${settings."turnOnSwitchesAfterSunset${lockStr}${user}"}" : ""
                }
            }

            if (settings."turnOnSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning on switches ${settings."turnOnSwitches${lockStr}${user}"}"
                settings."turnOnSwitches${lockStr}${user}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."turnOnSwitches${lockStr}${user}"}" : ""
            }

            if (settings."turnOffSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, turning off switches ${settings."turnOffSwitches${lockStr}${user}"}"
                settings."turnOffSwitches${lockStr}${user}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."turnOffSwitches${lockStr}${user}"}" : ""
            }
            
            if (settings."toggleSwitches${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, toggling switches ${settings."toggleSwitches${lockStr}${user}"}"
                settings."toggleSwitches${lockStr}${user}".each { dev ->
                	dev.currentValue("switch") == "on" ? dev?.off() : dev?.on()
                }
                msg += detailedNotifications ? ", toggling switches ${settings."toggleSwitches${lockStr}${user}"}" : ""
            }

            if (settings."unlockLocks${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, unlocking ${settings."unlockLocks${lockStr}${user}"}"
                settings."unlockLocks${lockStr}${user}"?.unlock()
                msg += detailedNotifications ? ", unlocking ${settings."unlockLocks${lockStr}${user}"}" : ""
            }

            if (settings."openGarage${lockStr}${user}") {
                log.info "$evt.displayName was unlocked successfully, opening ${settings."openGarage${lockStr}${user}"}"
                settings."openGarage${lockStr}${user}"?.open()
                msg += detailedNotifications ? ", opening ${settings."openGarage${lockStr}${user}"}" : ""
            }
        }

        // Check for one time codes and disable them if required
        def userType = settings."userType${i}" // User type
        def userLocks = (locks?.size() > 1) ? (settings."userLocks${i}" ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
        if (userLocks?.contains(lock.id) && (userType == 'One time')) {
            if (!state.usedOneTimeCodes[lock.id].contains(i as String)) {
                log.trace "Marking one time code as used and requesting removal from lock"
                state.usedOneTimeCodes[lock.id].add(i as String) // mark the user slot used
                codeCheck(true) // Check the expired code and remove from lock
            } else {
                log.warn "One time code is ALREADY marked as used"
            }
        }

        // Send notifications
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if (notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) {
            sendNotifications(msg, (settings."userOverrideNotifications${i}" && (settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : settings."userNotify${i}")) ? i as String : "")
        }
    }
}

def processLockEvent(evt) {
    def data = null
    def lock = locks.find { it.id == evt.lockId }

    log.trace "Processing $lock lock event: $evt"

    def msgs = [] // Message to send
    def user = "" // User slot used
    def i = 0 // Slot used
    
    if (evt.data) { // Was it locked using a user code
        data = parseJson(evt.data)
    }
    def lockMode = data?.type ?: (data?.method ?: (evt.descriptionText?.contains("manually") ? "manually" : "electronically"))
    // Fix for proper grammar and additional lock types mapping
    switch (lockMode) {
        case "manual":
        lockMode = "manually"
        break

        case "rfid":
        lockMode = "via RFID"
        break

        case "bluetooth":
        lockMode = "via bluetooth"
        break

        case "keypad":
        lockMode = "via keypad"
        break

        case "remote":
        case "command":
        lockMode = "remotely"
        break

        case "auto":
        lockMode = "via internal autolock"
        break

        default:
            break
    }

    evt.lockMode = lockMode // Save the lockMode calculated
    evt.data = data // Update the data to be passed
    user = (data?.usedCode as String) ?: ((data?.codeId as String) ?: "") // get the user if present
    i = ((data?.usedCode ?: 0) as Integer) ?: (((data?.codeId ?: 0) as Integer) ?: 0) // get the user if present
    log.trace "$lock locked by user $user $lockMode"

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || user) { // LOCKED VIA KEYPAD/RFID
        def name, notify, notifyCount, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions
        
        if (user) {
            if (i == 0) {
                name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                notify = true // always inform about master users
                user = "" // Master code uses general actions
            } else {
                name = settings."userNames${i}" ?: "Unknown user" // Should have a name for the user otherwise it's unknown
                notify = settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : false // UpdateSettings stores it as string
                notifyCount = settings."userNotifyUseCount${i}" ? (settings."userNotifyUseCount${i}" as Integer) : 0 // UpdateSettings stores as string
                notifyModes = settings."userNotifyModes${i}"
                notifyXPresence = settings."userXNotifyPresence${i}"
                userOverrideActions = settings."userOverrideUnlockActions${i}"

                // Check if we have user override lock actions defined
                if (!userOverrideActions) {
                    log.trace "No user $name specific lock action found, falling back to general actions"
                    user = "" // We don't have a user specific action defined, fall back to general actions
                }
            }
        } else {
            log.trace "No usercode found in extended data for external user lock"
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsTime${lockStr}${user}") {
            extLockNotify = settings."externalLockNotify${lockStr}"
            extLockNotifyModes = settings."externalLockNotifyModes${lockStr}"

            def msg = "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode, checking for actions in ${settings."delayLockActionsTime${lockStr}${user}"} minutes" // Default message to send
            log.debug msg
            if ((notify && (
                    (notifyModes ? notifyModes?.find{it == location.mode} : true) &&
                    (notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
                ) && (
                    !i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
            )) ||
                (!i && extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
                msgs << msg
            }
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            // If this came from a keypad and direct control is enabled, then start an exit code beep for all keypads with direct control
            if (data?.armMode) {
                if (settings."keypadArmDisarm${lock}${""}") { // If this keypad has direct control enabled
                    def keypads = locks?.findAll{ it.hasAttribute("armMode") } // Get all keypads
                    // We don't check for individual user custom actions for keypads since synchronization needs to happen at the keypad level
                    keypads = (settings."individualDoorActions${""}" ? keypads.findAll { keypad -> (settings."keypadArmDisarm${keypad}${""}") } : (settings."keypadArmDisarm${""}${""}" ? keypads : null)) // Get keypads with direct control enabled
                    if (keypads) {
                        log.trace "Direct keypad controls enabled, starting exit delay beeping for $keypads"
                        keypads*.setExitDelay(settings."delayLockActionsTime${lockStr}${user}" * 60) // Start exit delay beeping for delayed actions with direct control enabled
                    }
                }
            }
            startTimer(settings."delayLockActionsTime${lockStr}${user}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    } else { // MANUAL LOCK
        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        // Check if we have a delayed action and process accordingly
        if (settings."delayLockActionsTimeManual${lockStr}") {
            def msg = "$evt.displayName was locked $lockMode, checking for actions in ${settings."delayLockActionsTimeManual${lockStr}"} minutes" // Default message to send
            log.debug msg
            if (settings."lockNotify${lockStr}" && (!(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) && (settings."lockNotifyModes${lockStr}" ? settings."lockNotifyModes${lockStr}".find{it == location.mode} : true)) {
                msgs << msg
            }
            evt.sendNotifications = true // Since it's delayed we request notifications be sent
            startTimer(settings."delayLockActionsTimeManual${lockStr}" * 60, processLockActions, evt)
        } else {
            msgs += processLockActions(evt) // Take the message back to send out
        }
    }

    // Check if we need to retract a deadbolt lock it was locked while the door was still open
    /*if (settings."retractDeadbolt${lock}") { // SECURITY ISSUE - DISABLE
        def sensor = settings."sensor${lock}"
        if (sensor.latestValue("contact") == "open") {
            if (lock.hasAttribute('autolock') && (lock.latestValue("autolock") == "enabled")) { // Do not unlock if autolock features on the lock are enabled, avoid infinite loop
                def msg = "Disable AutoLock on $lock lock to avoid an infinite locking/unlocking loop while using the 'Unlock on door open' feature"
                log.warn msg
                msgs << msg
            } else {
                log.debug "$lock was locked while the door was still open, unlocking it in 10 seconds"
                def unlocks = atomicState.unLocks ?: [] // We need to deference the atomicState object each time and it may contain a null if it's empty so we need to allocate a new object, https://community.smartthings.com/t/atomicstate-not-working/27827/6?u=rboy
                if (!unlocks.contains(lock.id)) { // Don't re add the same lock again
                    //log.trace "Adding ${lock.id} to the list of unlocks"
                    unlocks.add(lock.id) // Atomic to ensure we get upto date info here
                    atomicState.unLocks = unlocks // Set it back, we can't work direct on atomicState
                }
                startTimer(10, unLockDoor) // Schedule the unlock in 10 seconds since the door may have just locked and avoid Z-Wave conflict and some locks like Schlage deadbolt have timing limitations which cause a busy conflict if done too soon
            }
        } else {
            log.trace "$lock was locked while the door was closed, we're good"
        }
    }*/

    // Last thing to do because it can timeout
    for (msg in msgs) {
        sendNotifications(msg, (settings."userOverrideNotifications${i}" && (settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : settings."userNotify${i}")) ? i as String : "")
    }
}

def processLockActions(evt) {
    def data = evt.data
    def lock = locks.find { it.id == evt.lockId }
    def msgs = [] // Message to send
    def lockMode = evt.lockMode
    def arm = "" // Security keypad arm mode (optional)
    def user = (data?.usedCode as String) ?: ((data?.codeId as String) ?: "") // get the user if present
    def i = ((data?.usedCode ?: 0) as Integer) ?: (((data?.codeId ?: 0) as Integer) ?: 0) // get the user if present

    log.trace "Processing $lock lock actions: $evt"

    if ((["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) }) || user) { // LOCKED VIA KEYPAD/RFID
        def name, notify, notifyCount, notifyModes, notifyXPresence, extLockNotify, extLockNotifyModes, userOverrideActions

        if (user) {
            if (i == 0) {
                name = "Master Code" // Special case locks like Yale have a master code which isn't programmable and is code 0
                notify = true // always inform about master users
                user = "" // Master code uses general actions
            } else {
                name = settings."userNames${i}" ?: "Unknown user" // Should have a name for the user otherwise it's unknown
                notify = settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : false // UpdateSettings stores it as string
                notifyCount = settings."userNotifyUseCount${i}" ? (settings."userNotifyUseCount${i}" as Integer) : 0 // UpdateSettings stores as string
                notifyModes = settings."userNotifyModes${i}"
                notifyXPresence = settings."userXNotifyPresence${i}"
                userOverrideActions = settings."userOverrideUnlockActions${i}"

                // Check if we have user override lock actions defined
                if (!userOverrideActions) {
                    log.trace "No user $name specific lock action found, falling back to general actions"
                    user = "" // We don't have a user specific action defined, fall back to general actions
                }
            }
        } else {
            log.trace "No usercode found in extended data for external user lock"
        }

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions${user}") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        extLockNotify = settings."externalLockNotify${lockStr}"
        extLockNotifyModes = settings."externalLockNotifyModes${lockStr}"

        log.trace "Lock $evt.displayName locked by $name, user notify $notify, notify count: $notifyCount, user notify modes $notifyModes, notify NOT present $notifyXPresence, external notify $extLockNotify, external notify modes $extLockNotifyModes, user override action $userOverrideActions, Source type: $lockMode"

        def msg = evt.sendNotifications ? "Completing check for lock actions for $evt.displayName" : "$evt.displayName was locked ${name ? "by " + name + " " : ""}$lockMode" // Default message to send

        if (settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActions${lockStr}${user}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActions${lockStr}${user}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            // If we have a specific mode passed by the keypad lets use that otherwise use configured options
            if (data?.armMode) {
                switch (data.armMode) { // Check for custom keypad arm actions
                    case "armedStay":
                    	if (settings."keypadArmActions${lockStr}${user}${"stay"}") {
                            log.debug "Running custom actions for keypad stay/partial button"
                            arm = "stay"
                        }
                        break
                        
                    case "armedNight":
                    	if (settings."keypadArmActions${lockStr}${user}${"night"}") {
                            log.debug "Running custom actions for keypad night button"
                            arm = "night"
                        }
                        break
                        
                    case "armedAway":
                    	if (settings."keypadArmActions${lockStr}${user}${"away"}") {
                            log.debug "Running custom actions for keypad away/on button"
                            arm = "away"
                        }
                        break
                        
                    default:
                        log.warn "Invalid keypad Arm mode detected: ${data.armMode}"
                    	msg += ", invalid keypad Arm mode ${data.armMode}"
                        break                        
                }
            }

            if ((settings."keypadArmDisarm${lockStr}${user}") && data?.armMode) {
                switch (data.armMode) { // Set Keypad lock state
                    case "armedStay":
                    case "armedNight":
                    	/*log.info "Arming Smart Home Monitor to Stay"
                        sendLocationEvent(name: "alarmSystemStatus", value: "stay") // Sync SHM
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""*/
                        /*try {
                            if (settings."adtDevices") {
                                log.info "Arming ADT to Stay"
                                settings."adtDevices"?.armStay('armedStay')
                                msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error arming ADT to Stay\n$e"
                            msg += ", error arming ADT to Stay"
                        }*/
                    	break
                    
                    case "armedAway":
                    	/*log.info "Arming Smart Home Monitor to Away"
                        sendLocationEvent(name: "alarmSystemStatus", value: "away") // Sync SHM
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""*/
                        /*try {
                            if (settings."adtDevices") {
                                log.info "Arming ADT to Away"
                                settings."adtDevices"?.armAway('armedAway')
                                msg += detailedNotifications ? ", Arming ADT to Away" : ""
                            }
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error arming ADT to Away\n$e"
                            msg += ", error arming ADT to Away"
                        }*/
                    	break
                        
                    default:
                        log.warn "Invalid keypad mode detected: ${data.armMode}"
                    	msg += ", invalid keypad mode ${data.armMode}"
                        break
                }
            } else {
                /*if (settings."homeArm${lockStr}${user}") { // Sync SHM
                    if (settings."homeArmStay${lockStr}${user}") {
                        log.info "Arming Smart Home Monitor to Stay"
                        sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
                    } else {
                        log.info "Arming Smart Home Monitor to Away"
                        sendLocationEvent(name: "alarmSystemStatus", value: "away")
                        msg += detailedNotifications ? ", Arming Smart Home Monitor to Away" : ""
                    }
                }*/
                
                /*try {
                    if (settings."adtArm${lockStr}${user}" && settings."adtDevices") {
                        if (settings."homeArmStay${lockStr}${user}") {
                            log.info "Arming ADT to Stay"
                            settings."adtDevices"?.armStay('armedStay')
                            msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                        } else {
                            log.info "Arming ADT to Away"
                            settings."adtDevices"?.armAway('armedAway')
                            msg += detailedNotifications ? ", Arming ADT to Away" : ""
                        }
                    }
                } catch (e) { // This is still not official so lets be cautious about it
                    log.error "Error arming ADT\n$e"
                    msg += ", error arming ADT"
                }*/
            }

            if (settings."externalLockMode${lockStr}${user}${arm}") {
                log.info "Changing mode to ${settings."externalLockMode${lockStr}${user}${arm}"}"
                if (location.modes?.find{it.name == settings."externalLockMode${lockStr}${user}${arm}"}) {
                    setLocationMode(settings."externalLockMode${lockStr}${user}${arm}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockMode${lockStr}${user}${arm}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockMode${lockStr}${user}${arm}"}" : ""
            }

            /*if (settings."externalLockPhrase${lockStr}${user}${arm}" && location.helloHome?.getPhrases()) {
                log.info "$evt.displayName was locked successfully, running routine ${settings."externalLockPhrase${lockStr}${user}${arm}"}"
                location.helloHome.execute(settings."externalLockPhrase${lockStr}${user}${arm}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhrase${lockStr}${user}${arm}"}" : ""
            }*/

            if (settings."externalLockTurnOnSwitches${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"}"
                settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitches${lockStr}${user}${arm}"}" : ""
            }

            if (settings."externalLockTurnOffSwitches${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"}"
                settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitches${lockStr}${user}${arm}"}" : ""
            }
            
            if (settings."externalLockToggleSwitches${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, toggling switches ${settings."externalLockToggleSwitches${lockStr}${user}${arm}"}"
                settings."externalLockToggleSwitches${lockStr}${user}${arm}".each { dev ->
                	dev.currentValue("switch") == "on" ? dev?.off() : dev?.on()
                }
                msg += detailedNotifications ? ", toggling switches ${settings."externalLockToggleSwitches${lockStr}${user}${arm}"}" : ""
            }

            if (settings."lockLocks${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocks${lockStr}${user}${arm}"}"
                settings."lockLocks${lockStr}${user}${arm}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocks${lockStr}${user}${arm}"}" : ""
            }

            if (settings."closeGarage${lockStr}${user}${arm}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarage${lockStr}${user}${arm}"}"
                settings."closeGarage${lockStr}${user}${arm}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarage${lockStr}${user}${arm}"}" : ""
            }
        }

        // Send a notification if required (message would be updated)
        if (i) { // If we have a known user, increment the usage count
            state.codeUseCount[lock.id][i as String] = (state.codeUseCount[lock.id][i as String] ?: 0) + 1
        }
        if ((notify && (
            	(notifyModes ? notifyModes?.find{it == location.mode} : true) &&
            	(notifyXPresence ? notifyXPresence.every{it.currentPresence != "present"} : true)
            ) && (
            	!i || (notifyCount ? (state.codeUseCount[lock.id][i as String] <= notifyCount) : true)
        )) ||
            (!i && extLockNotify && (extLockNotifyModes ? extLockNotifyModes.find{it == location.mode} : true))) {
            msgs << msg
        }
    } else { // MANUAL LOCK
        log.trace "Lock $evt.displayName locked manually, Source type: $lockMode"

        // Check if we have individual actions for each lock
        def lockStr = ""
        if (settings."individualDoorActions") {
            lockStr = lock as String
        } else {
            lockStr = ""
        }

        def msg = evt.sendNotifications ? "Completing check for lock actions for $evt.displayName" : "$evt.displayName was locked $lockMode" // Default message to send

        if (settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}) {
            log.trace "${settings."runXPeopleLockActionsManual${lockStr}"?.find{it.currentPresence == "present"}} is present, not running lock actions for door $lock"
        } else if (settings."runXModeLockActionsManual${lockStr}"?.find{it == location.mode}) {
            log.trace "Current mode is ${location.mode}, not running lock actions for door $lock"
        } else {
            /*if (settings."homeArmManual${lockStr}") { // Sync SHM
                log.info "Arming Smart Home Monitor to Stay"
                sendLocationEvent(name: "alarmSystemStatus", value: "stay")
                msg += detailedNotifications ? ", Arming Smart Home Monitor to Stay" : ""
            }*/

            /*try {
                if (settings."adtArmManual${lockStr}" && settings."adtDevices") {
                    if (settings."homeArmAwayManual${lockStr}") {
                        log.info "Arming ADT to Away"
                        settings."adtDevices"?.armAway('armedAway')
                        msg += detailedNotifications ? ", Arming ADT to Away" : ""
                    } else {
                        log.info "Arming ADT to Stay"
                        settings."adtDevices"?.armStay('armedStay')
                        msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                    }
                }
            } catch (e) { // This is still not official so lets be cautious about it
                log.error "Error arming ADT to Stay\n$e"
                msg += ", error arming ADT to Stay"
            }*/

            if (settings."externalLockModeManual${lockStr}") {
                log.info "Changing mode to ${settings."externalLockModeManual${lockStr}"}"
                if (location.modes?.find{it.name == settings."externalLockModeManual${lockStr}"}) {
                    setLocationMode(settings."externalLockModeManual${lockStr}") // First do this to avoid false alerts from a slow platform
                }  else {
                    log.warn "Tried to change to undefined mode '${settings."externalLockModeManual${lockStr}"}'"
                }
                msg += detailedNotifications ? ", changing mode to ${settings."externalLockModeManual${lockStr}"}" : ""
            }

            /*if (settings."externalLockPhraseManual${lockStr}" && location.helloHome?.getPhrases()) {
                log.info "$evt.displayName was locked successfully, running routine ${settings."externalLockPhraseManual${lockStr}"}"
                location.helloHome.execute(settings."externalLockPhraseManual${lockStr}")
                msg += detailedNotifications ? ", running ${settings."externalLockPhraseManual${lockStr}"}" : ""
            }*/

            if (settings."externalLockTurnOnSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}"
                settings."externalLockTurnOnSwitchesManual${lockStr}"?.on()
                msg += detailedNotifications ? ", turning on switches ${settings."externalLockTurnOnSwitchesManual${lockStr}"}" : ""
            }

            if (settings."externalLockTurnOffSwitchesManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}"
                settings."externalLockTurnOffSwitchesManual${lockStr}"?.off()
                msg += detailedNotifications ? ", turning off switches ${settings."externalLockTurnOffSwitchesManual${lockStr}"}" : ""
            }

            if (settings."lockLocksManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, locking ${settings."lockLocksManual${lockStr}"}"
                settings."lockLocksManual${lockStr}"?.lock()
                msg += detailedNotifications ? ", locking ${settings."lockLocksManual${lockStr}"}" : ""
            }

            if (settings."closeGarageManual${lockStr}") {
                log.info "$evt.displayName was locked successfully, closing garage ${settings."closeGarageManual${lockStr}"}"
                settings."closeGarageManual${lockStr}"?.close()
                msg += detailedNotifications ? ", closing garage ${settings."closeGarageManual${lockStr}"}" : ""
            }
        }

        // Send notitications for manual and electronic locking only, keypad is handled above with lock actions
        if (settings."lockNotify${lockStr}" && (!(["keypad", "rfid"].any { lockMode?.toLowerCase().contains(it) })) && (settings."lockNotifyModes${lockStr}" ? settings."lockNotifyModes${lockStr}".find{it == location.mode} : true)) {
            msgs << msg
        }
    }
    
    // Check if we are asked to send the notifications or return them back
    if (evt.sendNotifications) {
        // Last thing to do because it can timeout
        for (msg1 in msgs) {
            sendNotifications(msg1, (settings."userOverrideNotifications${i}" && (settings."userNotify${i}" ? settings."userNotify${i}".toBoolean() : settings."userNotify${i}")) ? i as String : "")
        }
    } else {
        return msgs
    }
}

def runCheckInOutActions() {
    if (!rentalUnitsCount) {
        log.warn "No properties defined, no CheckIn/CheckOut actions to process"
        return // We're done here
    }
    
    if (!maxRentalUsers) {
        log.warn "No automatic renter users defined, skipping CheckIn/CheckOut actions to process"
        return // We're done here
    }

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    log.trace "CheckInOut Actions: The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // 'no' goes from 1 to rentalUnitsCount
    for (no in (1..rentalUnitsCount)) { // Check if we have any pending Check In or Check Out actions for each unit
        def action
        def lastRun, nextRun
        def skipCheckOut = false // Check out cannot run after a check in has happened (if check in and check out are on same day)
        def msgs = []
        def propertyName = settings."propertyName${unitSuffixes[no]}" ?: "" // Don't use null

        /*log.trace "$propertyName: CheckIn/CheckOut states" +
            "\nLast CheckIn Run:${(new Date(state.checkInLastRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
            "\nNext CheckIn Run:${(new Date(state.checkInNextRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
            "\nLast CheckOut Run:${(new Date(state.checkOutLastRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
            "\nNext CheckOut Run:${(new Date(state.checkOutNextRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"*/

        // Check what kind of action are we running
        if ((now() > state.checkInNextRun[(no as String)]) && (state.checkInLastRun[(no as String)] < state.checkInNextRun[(no as String)])) {
            action = "checkIn"
            lastRun = state.checkInLastRun[(no as String)]
            nextRun = state.checkInNextRun[(no as String)]
            // Check out cannot run after a check in has happened (if check in and check out are on same day)
            if (state.checkOutNextRun[(no as String)] > state.checkInNextRun[(no as String)]) {
                skipCheckOut = true
            }
        } else if ((now() > state.checkOutNextRun[(no as String)]) && (state.checkOutLastRun[(no as String)] < state.checkOutNextRun[(no as String)])) {
            action = "checkOut"
            lastRun = state.checkOutLastRun[(no as String)]
            nextRun = state.checkOutNextRun[(no as String)]
        } else { // This can happen when one room action is triggered, the other rooms may be invalid, just skip
            continue // We're done with this property
        }

        if (settings."${action}EnableActions${no}") { // If have any actions configured
            def msg = "Running $action actions for $propertyName\nLast Run:${lastRun ? (new Date(lastRun)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "none"}\nScheduled Run:${nextRun ? (new Date(nextRun)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "none"}"
            log.info msg

            // Check for non running conditions
            if (settings."${action}ActionsXPeople${no}"?.find{it.currentPresence == "present"}) {
                log.trace "${settings."${action}ActionsXPeople${no}"?.find{it.currentPresence == "present"}} is present, not running $action actions for $propertyName"
            } else if (settings."${action}ActionsXMode${no}"?.find{it == location.mode}) {
                log.trace "Current mode is ${location.mode}, not running $action actions for $propertyName"
            } else {
                msg = "$propertyName: Running ${action == "checkIn" ? "check-in" : "check-out"} actions" + (skipCheckOut ? " before today's check-out actions" : "")

                // ADT Controls - First do this to avoid false alerts from a slow platform
                /*if (settings."${action}Adt${no}" && settings."adtDevices") {
                    if (action == "checkOut") {
                        try {
                            log.info "Arming ADT to Stay"
                            settings."adtDevices"?.armStay('armedStay')
                            msg += detailedNotifications ? ", Arming ADT to Stay" : ""
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error arming ADT to Stay\n$e"
                            msg += ", error arming ADT to Stay"
                        }
                    } else {
                        try {
                            log.info "Disarming ADT"
                            settings."adtDevices"?.disarm()
                            msg += detailedNotifications ? ", disarming ADT" : ""
                        } catch (e) { // This is still not official so lets be cautious about it
                            log.error "Error disarming ADT\n$e"
                            msg += ", error disarming ADT"
                        }
                    }
                }*/

                // Mode
                if (settings."${action}HomeMode${no}") {
                    log.info "Changing mode to ${settings."${action}HomeMode${no}"}"
                    if (location.modes?.find{it.name == settings."${action}HomeMode${no}"}) {
                        setLocationMode(settings."${action}HomeMode${no}") // First do this to avoid false alerts from a slow platform
                    }  else {
                        log.warn "$action for $propertyName tried to change to undefined mode '${settings."${action}HomeMode${no}"}'"
                    }
                    msg += detailedNotifications ? ", changing mode to ${settings."${action}HomeMode${no}"}" : ""
                }
                
                // Routines
                /*if (settings."${action}Phrase${no}" && location.helloHome?.getPhrases()) {
                    log.info "Running Routine ${settings."${action}Phrase${no}"}"
                    location.helloHome.execute(settings."${action}Phrase${no}") // First do this to avoid false alerts from a slow platform
                    msg += detailedNotifications ? ", running routine ${settings."${action}Phrase${no}"}" : ""
                }*/
                
                // Lights after dark
                if (settings."${action}TurnOnSwitchesAfterSunset${no}") {
                    def cdt = new Date(now())
                    def sunsetSunrise = getSunriseAndSunset(sunsetOffset: "-00:30") // Turn on 30 minutes before sunset (dark)
                    log.trace "Current DT: $cdt, Sunset $sunsetSunrise.sunset, Sunrise $sunsetSunrise.sunrise"
                    if ((cdt >= sunsetSunrise.sunset) || (cdt <= sunsetSunrise.sunrise)) {
                        log.info "Turning on lights ${settings."${action}TurnOnSwitchesAfterSunset${no}"} since it's after sunset but before sunrise"
                        settings."${action}TurnOnSwitchesAfterSunset${no}"?.on()
                        msg += detailedNotifications ? ", turning on lights ${settings."${action}TurnOnSwitchesAfterSunset${no}"}" : ""
                    }
                }

                // Switches on
                if (settings."${action}TurnOnSwitches${no}") {
                    log.info "Turning on switches ${settings."${action}TurnOnSwitches${no}"}"
                    settings."${action}TurnOnSwitches${no}"?.on()
                    msg += detailedNotifications ? ", turning on switches ${settings."${action}TurnOnSwitches${no}"}" : ""
                }

                // Switches off
                if (settings."${action}TurnOffSwitches${no}") {
                    log.info "Turning off switches ${settings."${action}TurnOffSwitches${no}"}"
                    settings."${action}TurnOffSwitches${no}"?.off()
                    msg += detailedNotifications ? ", turning off switches ${settings."${action}TurnOffSwitches${no}"}" : ""
                }

                // Set thermostats
                if (settings."${action}SetThermostats${no}") { // Auto thermostats
                    log.info "Setting thermostat ${settings."${action}SetThermostats${no}"} setpoints Heat: ${settings."${action}SetThermostatsHeat${no}"}°, Cool: ${settings."${action}SetThermostatsCool${no}"}°"
                    def msg1 = ""
                    if (settings."${action}SetThermostatsHeat${no}") {
                    	settings."${action}SetThermostats${no}"?.setHeatingSetpoint(settings."${action}SetThermostatsHeat${no}")
                        msg1 += " heat to ${settings."${action}SetThermostatsHeat${no}"}°"
                    }
                    if (settings."${action}SetThermostatsCool${no}") {
                    	settings."${action}SetThermostats${no}"?.setCoolingSetpoint(settings."${action}SetThermostatsCool${no}")
                        msg1 += " cool to ${settings."${action}SetThermostatsCool${no}"}°"
                    }
                    if (msg1) {
                    	msg += detailedNotifications ? ", setting thermostats ${settings."${action}SetThermostats${no}"}" + msg1 : ""
                    }
                }
                if (settings."${action}SetThermostatsHeating${no}") { // Heating thermostats
                    log.info "Setting thermostat ${settings."${action}SetThermostatsHeating${no}"} setpoints Heat: ${settings."${action}SetThermostatsHeat${no}"}°"
                    def msg1 = ""
                    if (settings."${action}SetThermostatsHeat${no}") {
                    	settings."${action}SetThermostatsHeating${no}"?.setHeatingSetpoint(settings."${action}SetThermostatsHeat${no}")
                        msg1 += " heat to ${settings."${action}SetThermostatsHeat${no}"}°"
                    }
                    if (msg1) {
                    	msg += detailedNotifications ? ", setting thermostats ${settings."${action}SetThermostatsHeating${no}"}" + msg1 : ""
                    }
                }
                if (settings."${action}SetThermostatsCooling${no}") { // Cooling thermostats
                    log.info "Setting thermostat ${settings."${action}SetThermostatsCooling${no}"} setpoints Cool: ${settings."${action}SetThermostatsCool${no}"}°"
                    def msg1 = ""
                    if (settings."${action}SetThermostatsCool${no}") {
                    	settings."${action}SetThermostatsCooling${no}"?.setCoolingSetpoint(settings."${action}SetThermostatsCool${no}")
                        msg1 += " cool to ${settings."${action}SetThermostatsCool${no}"}°"
                    }
                    if (msg1) {
                    	msg += detailedNotifications ? ", setting thermostats ${settings."${action}SetThermostatsCooling${no}"}" + msg1 : ""
                    }
                }

                msgs << msg
            }
        } else {
            log.trace "$action actions not enabled for $propertyName\nLast Run:${lastRun ? (new Date(lastRun)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "none"}\nScheduled Run:${nextRun ? (new Date(nextRun)).format("EEE MMM dd yyyy HH:mm z", timeZone) : "none"}"
        }

        // At the END update the last time we ran Check in/out actions and save it so we know it ran
        if (action == "checkIn") {
            def nowTime = now()
            if (skipCheckOut) {
                state.checkOutLastRun[(no as String)] = nowTime
            }
            state.checkInLastRun[(no as String)] = nowTime
        } else {
            state.checkOutLastRun[(no as String)] = now()
        }

        if (!settings."${action}EnableActions${no}") { // If there were no enabled actions then process the next Unit right away
            continue
        }

        // Come back and check the next property pending actions to avoid a timeout
        startTimer(1, runCheckInOutActions) // Schedule it to run we have only one pending execution at a time

        // Do this in the end otherwise it may timeout
        if (rentalProgrammingNotifications && withinRentalProgrammingNotificationTimes()) { // Push only within rental programming notification times
            msgs.each { msg -> sendNotifications(msg) }
        } else {
            msgs.each { msg -> sendNotificationEvent(msg) }
        }

        return // We're done here
    }
}

def clearAllCodes() {
    log.trace "Clearing codes from locks"
    
    def msgs = []

    if ((maxUserNames != null) && ((maxUserNames as Integer) > 0)) { // Clear all users
        log.debug "Clearing user slots 1 to ${maxUserNames}"
        startTimer(1, removeRentalUsersOffline, [ data : [start: 1, end: (maxUserNames as Integer)] ]) // Clear the slots

        for (lock in locks) {
            def msg = "Marking first ${maxUserNames} users to be cleared from ${lock}"
            def user = 1
            while (user <= maxUserNames) {
                // ST can't clear too many codes at once, so lets mark the previous code as populated so the app will clear it eventually
                state.lockCodes[lock.id][user as String] = "1" // Indicate (special) previous code so the app will clear it later
                user++
            }
            
            //log.trace msg
            //msgs << msg
        }

        def totalClearingTime = ((((locks?.size() ?: 0) * (maxUserNames as Integer) * (sendDelay ?: 5)) / 60) as Integer) + 1
        if (totalClearingTime) {
            def msg = "${app.label} may take about ${totalClearingTime} minutes to clear the users from the locks"
            log.debug msg
            msgs << msg
        }
    } // Clear excess users offline so it doesn't slow down the UI (do it while reducing users so that when you increase the slots are already cleared)
    
    deleteSetting("clearUserCodes") // We're done with clearing - reset it

    startTimer(1, kickStart) // It takes the lock about 15 seconds to clear the codes and finish up pending commands

    // Last thing to do since it could timeout
    for (msg in msgs) {
        //log.trace msg
        sendNotifications(msg)
    }
}

def codeCheck(userUpdate = false) {
    // Check if the user has upgraded the SmartApp and reinitailize if required
    if (state.clientVersion && (state.clientVersion != clientVersion())) { // Check for platform outage (null)
    	state.nextRentalUpdateCheck = now() // Force a download of the rental data after an upgrade
        def msg = "NOTE: ${app.label} detected a code upgrade. Updating configuration, please open the app and re-validate your settings"
        log.warn msg
        startTimer(1, appTouch) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
        //sendPush msg // Do this in the end as it may timeout
        return
    }

    log.warn "READ THIS BEFORE PROCCEDING: IT IS NORMAL TO SEE DEBUG MESSAGES EVERY MINUTE, IT CONFIRMS THAT THE APP IS HEALTHY AND RUNNING IN THE CLOUD. IT DOES NOT COMMUNICATE WITH THE LOCK UNLESS YOU SEE A MESSAGE BOX SAYING 'REQUESTED LOCK TO XXXXX'."

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    log.trace "The date/time on the hub now is ${(new Date(now())).format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Hack for broken ST timers - Schedule the Heartbeat
    if (((state.lastHeartBeat ?: 0) + ((10+5)*60*1000) < now()) && canSchedule()) { // Since we are scheduling the heartbeat every 10 minutes, give it a 5 minute grace
        log.warn "Heartbeat not called in last 15 minutes, rescheduling heartbeat"
        schedule("* */10 * * * ?", heartBeatMonitor) // run the heartbeat every 10 minutes
        state.lastHeartBeat = now() // give it 10 minutes before you schedule it again
    }

    if (!userUpdate) { // If we don't have a critical user update
        // Check if we need to process the last downloaded update (even if rentalUnitsCount is 0, we need to clean up the downloaded data/users)
        def lastUpdate = 0
        def lastProcess = 0

        unitSuffixes.each { no, suffix ->
            def airbnbEntryUpdated = atomicState."unit${no}AirbnbUpdated"
            def vrboEntryUpdated = atomicState."unit${no}VrboUpdated"
            def homeAwayEntryUpdated = atomicState."unit${no}HomeAwayUpdated"
            def bookingEntryUpdated = atomicState."unit${no}BookingUpdated"
            def tripAdvisorEntryUpdated = atomicState."unit${no}TripAdvisorUpdated"
            def expediaEntryUpdated = atomicState."unit${no}ExpediaUpdated"
            def genericEntryUpdated = atomicState."unit${no}GenericUpdated"
            def airbnbEntryProcessed = atomicState."unit${no}AirbnbProcessed"
            def vrboEntryProcessed = atomicState."unit${no}VrboProcessed"
            def homeAwayEntryProcessed = atomicState."unit${no}HomeAwayProcessed"
            def bookingEntryProcessed = atomicState."unit${no}BookingProcessed"
            def tripAdvisorEntryProcessed = atomicState."unit${no}TripAdvisorProcessed"
            def expediaEntryProcessed = atomicState."unit${no}ExpediaProcessed"
            def genericEntryProcessed = atomicState."unit${no}GenericProcessed"
            lastUpdate = [ lastUpdate, airbnbEntryUpdated, vrboEntryUpdated, homeAwayEntryUpdated, bookingEntryUpdated, tripAdvisorEntryUpdated, expediaEntryUpdated, genericEntryUpdated].max() // Get the latest update
            lastProcess = [ lastProcess, airbnbEntryProcessed, vrboEntryProcessed, homeAwayEntryProcessed, bookingEntryProcessed, tripAdvisorEntryProcessed, expediaEntryProcessed, genericEntryProcessed].max() // Get the latest process
        }

        // If the last time we processed this was before it was downloaded then time to download it again
        if (lastProcess < lastUpdate) {
            log.debug "Found rental calendar schedules to process, last update ${(new Date(lastUpdate)).format("EEE MMM dd yyyy HH:mm z", timeZone)}, last processed ${(new Date(lastProcess)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
            processRentalUsers()
        } else if (rentalUnitsCount) { // Check if we need to run any CheckIn/CheckOut actions if we have any properties configured
            if (unitSuffixes.any { no, suffix ->
                /*log.trace "Checking for pending actions for ${settings."propertyName${unitSuffixes[no]}" ?: "Unit ${no}"}" +
                    "\nLast CheckIn Run:${(new Date(state.checkInLastRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
                    "\nNext CheckIn Run:${(new Date(state.checkInNextRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
                    "\nLast CheckOut Run:${(new Date(state.checkOutLastRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}" +
                    "\nNext CheckOut Run:${(new Date(state.checkOutNextRun[(no as String)] ?: 0)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"*/
                return (((now() > state.checkInNextRun[(no as String)]) && (state.checkInLastRun[(no as String)] < state.checkInNextRun[(no as String)])) ||
                        ((now() > state.checkOutNextRun[(no as String)]) && (state.checkOutLastRun[(no as String)] < state.checkOutNextRun[(no as String)])))
            }) {
                startTimer(1, runCheckInOutActions) // Schedule it to run we have only one pending execution at a time
            }
        }
    }

    // Update the last time we can code check
    state.lastCheck = now()

    for (lock in locks) {
    	if ((state.lockCodes == null) || (state.lockCodes[lock.id] == null) || (state.retryCodeCount[lock.id] == null)) { // If we have a situation where the user added a new lock without tapping save reinitialize the app
            def msg = "${app.label} detected an unsaved configuration change. Reinitializing the app, please open the app and re-validate your settings"
            log.warn msg
            startTimer(1, appTouch) // Reinitialize the app offline to avoid a loop as appTouch calls codeCheck
            return // We're done here
        }
        
        if (state.expiredLockList.contains(lock.id)) { // this lock codes hasn't been completely initiated
            //log.trace "If you're seeing this every few minutes, then ST is alive and kicking - ST cloud codes status for $lock"
            while (state.expiredNextCode <= maxUserNames) { // cycle through all the codes
                //log.trace "ST Cloud status for code $state.expiredNextCode on $lock"
                def i = state.expiredNextCode
                def name = settings."userNames${i}"?.trim() // Get the name for the slot and clear and leading or trailing spaces
                def code = settings."userCodes${i}" as String // Get the code for the slot
                def userType = settings."userType${i}" // User type
                def expDate = settings."userExpireDate${i}" // Get the expiration date
                def expTime = settings."userExpireTime${i}" // Get the expiration time
                def startDate = settings."userStartDate${i}" // Get the start date
                def startTime = settings."userStartTime${i}" // Get the start time
                def userPresent = settings."userPresent${i}" // Get user presence
                def userNotPresent = settings."userNotPresent${i}" // Get user not presence
                def userModes = settings."userModes${i}" // Get user modes
                def userLocks = (locks?.size() > 1) ? (settings."userLocks${i}" ?: locks*.id) : locks*.id // If not defined or only one lock then check all locks
                def user = i as Integer // which user slot are we using, convert to integer to be sure
                def msg = ""
                def extraNotifications = detailedNotifications

                //log.trace "CodeCheck $i, Name: $name, Code: $code, UserType: $userType, ExpireDate: $expDate, ExpireTime: $expTime, StartDate: $startDate, StartTime: $startTime, Present: $userPresent, Not Present: $userNotPresent, UserModes: $userModes, Locks: $userLocks"

                // Check if we have more than one lock and use has not selected this lock for programming then delete it
                if (!userLocks?.contains(lock.id)) {
                    if (state.lockCodes[lock.id].(user as String)) {
                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                            msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                            log.warn msg
                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                extraNotifications = true // We need to inform the user
                            } else {
                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                msg = "" // Don't message endlessly
                            }
                        } else {
                            deleteCode(lock, user)
                            msg = "Requesting $lock to delete unconfigured user $user ${name ?: ""}"
                            log.debug msg
                        }

                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work
                        
                        // Last thing to do since it could timeout
                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                        return // We are done here, exit out as we've scheduled the next update
                    } else {
                        log.debug "$lock ${name ?: ""} user $user already unconfigured"
                    }
                } else {
                    // Check code type
                    switch (userType) {
                        case 'Expire on':
                            if (code != null) {
                                def doAdd = false
                                if (expDate && expTime) {
                                    try {
                                        // Parse the entire date/time including timezone since the Date object is converted and stored in UTC internally
                                        def exp = Date.parse("yyyy-MM-ddHH:mmZ", expDate + timeToday(expTime, timeZone).format("HH:mmZ", timeZone))
                                        def expStr = exp.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                        if (exp.getTime() > now()) {
                                            if (startDate && startTime) {
                                                try {
                                                    def start = Date.parse("yyyy-MM-ddHH:mmZ", startDate + timeToday(startTime, timeZone).format("HH:mmZ", timeZone))
                                                    def startStr = start.format("EEE MMM dd yyyy HH:mm z", timeZone)
                                                    if (start.getTime() <= now()) {
                                                        msg = "Requesting $lock to add $name to user $user, code: $code, because it is scheduled to start at $startStr and expire on $expStr"
                                                        doAdd = true // we need to add the code
                                                        //log.trace "$lock User $user $name is scheduled to start at $startStr and expire on $expStr"
                                                    } else {
                                                        msg = "Requesting $lock to delete future user $user $name, start on $startStr"
                                                        //log.trace "$lock user $user $name's code is set to start in future on $startStr"
                                                    }
                                                } catch (Exception e) {
                                                    log.error "User $user $name set to Start but does not have a valid Start Date: $startDate"
                                                }
                                            } else if (startDate && !startTime) {
                                                log.error "User $user $name set to Start but does not have a valid Start Date/Time: $startDate or Time: $startTime"
                                            } else {
                                                msg = "Requesting $lock to add $name to user $user, code: $code, it is set to expire on $expStr"
                                                doAdd = true // we need to add the code
                                                //log.trace "$lock User $user $name is set to expire on $expStr"
                                            }
                                        } else {
                                            msg = "Requesting $lock to delete expired user $user $name, expired on $expStr"
                                        }
                                    } catch (Exception e) {
                                        log.error "User $user $name set to Expire but does not have a valid Expiry Date: $expDate or Time: $expTime"
                                    }
                                } else {
                                    log.error "$lock User $user $name set to Expire but does not have a Expiration Date: $expDate or Time: $expTime"
                                }

                                if (doAdd) {
                                    if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            setCode(lock, user, code, name)
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    } else {
                                        if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                            updateCodeName(lock, user, name)
                                        }
                                        log.debug "$lock User $user $name is already active"
                                    }
                                } else {
                                    if (state.lockCodes[lock.id].(user as String)) {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            deleteCode(lock, user)
                                            msg = msg ?: "Requesting $lock to delete user invalid $user ${name ?: ""}"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    } else {
                                        log.debug "$lock User $user $name is already deleted"
                                    }
                                }
                            } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user already deleted"
                            }
                            break

                        case 'One time':
                            if (code != null) {
                                if (state.usedOneTimeCodes[lock.id].contains(user as String)) {
                                    if (!state.trackUsedOneTimeCodes.contains(user as String)) {
                                        state.trackUsedOneTimeCodes.add(user as String) // track it for reporting purposes
                                    }

                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                        msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                        log.warn msg
                                        if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                            extraNotifications = true // We need to inform the user
                                        } else {
                                            state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                            msg = "" // Don't message endlessly
                                        }
                                    } else {
                                        deleteCode(lock, user)
                                        msg = "Requesting $lock to delete one time user $user ${name ?: ""}"
                                        log.debug msg
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                } else if (!state.trackUsedOneTimeCodes.contains(user as String)) { // If it's not been used add it to the lock
                                    if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            setCode(lock, user, code, name)
                                            msg = "Requesting $lock to add one time user $user ${name ?: ""}, code: $code"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    } else {
                                        if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                            updateCodeName(lock, user, name)
                                        }
                                        log.debug "$lock User $user $name is a one time code but it has not been used yet"
                                    }
                                } else {
                                    log.debug "$lock one time user $user $name is already used"
                                }
                            } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user already deleted"
                            }
                            break

                        case 'Scheduled':
                            if (code != null) {
                                def doAdd = false

                                schedulesSuffix.each { schedule ->
                                    if (checkSchedule(i, schedule)) { // Check if we are within operating schedule
                                        doAdd = true
                                        msg = "Schedule $schedule active $lock to add $name to user $user, code: $code, because it is scheduled to work between ${settings."userDayOfWeek${schedule}${i}"}: ${settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""} to ${settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""}"
                                        log.trace msg
                                    } else {
                                        msg = "Schedule $schedule NOT active for $lock $name user $user, scheduled to work between ${settings."userDayOfWeek${schedule}${i}"}: ${settings."userStartTime${schedule}${i}" ? timeToday(settings."userStartTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""} to ${settings."userEndTime${schedule}${i}" ? timeToday(settings."userEndTime${schedule}${i}", timeZone).format("HH:mm z", timeZone) : ""}"
                                        log.trace msg
                                    }
                                }

                                if (doAdd) {
                                    if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                        if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                            updateCodeName(lock, user, name)
                                        }
                                        log.debug "$lock scheduled user $user $name is already active, not adding again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            setCode(lock, user, code, name)
                                            msg = "Requesting $lock to add active scheduled user $user ${name ?: ""}, code: $code"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                } else { // Outside operating schedule
                                    if (!state.lockCodes[lock.id].(user as String)) {
                                        log.debug "$lock scheduled user $user $name is already inactive, not removing again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            deleteCode(lock, user)
                                            msg = "Requesting $lock to delete inactive scheduled user $user ${name ?: ""}"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                }
                            } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user already deleted"
                            }
                            break

                        case 'Permanent':
                            if (code != null) {
                                if (state.lockCodes[lock.id].(user as String) != code) { // Only if code has changed
                                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                        msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                        log.warn msg
                                        if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                            extraNotifications = true // We need to inform the user
                                        } else {
                                            state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                            msg = "" // Don't message endlessly
                                        }
                                    } else {
                                        setCode(lock, user, code, name)
                                        msg = "Requesting $lock to add permanent user $user ${name ?: ""}, code: $code"
                                        log.debug msg
                                    }

                                    state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                    // Last thing to do since it could timeout
                                    (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                    return // We are done here, exit out as we've scheduled the next update
                                } else {
                                    if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                        updateCodeName(lock, user, name)
                                    }
                                    log.debug "$lock User $user $name is a permanent code and is already active"
                                }
                            } else if (state.lockCodes[lock.id].(user as String)) { // Code is null but the list shows programmed, i.e. we were asked to explicit send a delete command to the lock
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user already deleted"
                            }
                            break

                        case 'Presence':
                            if (code != null) {
                                def doAdd = false

                                // Any of the 'present' users AND none of the 'not present' users are there then the code is active
                                if ((userPresent || userNotPresent) && // Atleast one condition is specified
                                    (userPresent ? userPresent.any{it.currentPresence == "present"} : true) &&
                                    (userNotPresent ? userNotPresent.every{it.currentPresence != "present"} : true)
                                   ) {
                                    doAdd = true // the code
                                    msg = "$lock user $user $name is being added because ${userPresent ? "${userPresent.findAll{it.currentPresence == "present"}} are present" : (userNotPresent ? "${userNotPresent} are not present" : "")}"
                                    log.debug msg
                                } else {
                                    msg = "$lock user $user $name is being deleted because${(userPresent || userNotPresent) ? (userPresent.every{it.currentPresence != "present"} ? " ${userPresent} are not present" : (userNotPresent ? " ${userNotPresent.findAll{it.currentPresence == "present"}} are present" : "")) : " no user presence is defined"}"
                                    log.debug msg
                                }

                                if (doAdd) {
                                    if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                        if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                            updateCodeName(lock, user, name)
                                        }
                                        log.debug "$lock presence user $user $name is already active, not adding again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            setCode(lock, user, code, name)
                                            msg = "Requesting $lock to add presence based user $user ${name ?: ""}, code: $code"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                } else { // Presence conditions not satisfied
                                    if (!state.lockCodes[lock.id].(user as String)) {
                                        log.debug "$lock presence user $user $name is already inactive, not removing again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            deleteCode(lock, user)
                                            msg = "Requesting $lock to delete presence based user $user ${name ?: ""}"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                }
                            }
                            break

                        case 'Modes':
                            if (code != null) {
                                def doAdd = false

                                // Any of the selected modes are active then activate the codes
                                if (userModes?.find{it == location.mode}) {
                                    doAdd = true // the code
                                    msg = "$lock user $user $name is being added because mode ${location.mode} is active"
                                    log.debug msg
                                } else {
                                    msg = "$lock user $user $name is not being deleted because mode ${location.mode} is not in the selected modes"
                                    log.debug msg
                                }

                                if (doAdd) {
                                    if (state.lockCodes[lock.id].(user as String) == code) { // If code hasn't changed, don't add it
                                        if (getCodeName(lock, user) && (getCodeName(lock, user) != name)) { // If the username has changed update it, if it's empty ignore it
                                            updateCodeName(lock, user, name)
                                        }
                                        log.debug "$lock mode user $user $name is already active, not adding again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} addition not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            setCode(lock, user, code, name)
                                            msg = "Requesting $lock to add mode based user $user ${name ?: ""}, code: $code"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                } else { // Mode conditions not satisfied
                                    if (!state.lockCodes[lock.id].(user as String)) {
                                        log.debug "$lock mode user $user $name is already inactive, not removing again"
                                    } else {
                                        if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                            msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                            log.warn msg
                                            if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                                extraNotifications = true // We need to inform the user
                                            } else {
                                                state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                                msg = "" // Don't message endlessly
                                            }
                                        } else {
                                            deleteCode(lock, user)
                                            msg = "Requesting $lock to delete mode based user $user ${name ?: ""}"
                                            log.debug msg
                                        }

                                        state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                        //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                        startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                        // Last thing to do since it could timeout
                                        (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                        return // We are done here, exit out as we've scheduled the next update
                                    }
                                }
                            }
                            break

                        case 'Inactive':
                            if (state.lockCodes[lock.id].(user as String)) { // Delete the code is hasn't been deleted
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete inactive user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user already inactive"
                            }
                            break

                        default: // No user type selected, it's empty delete code
                            if (state.lockCodes[lock.id].(user as String)) { // Delete the code is hasn't been deleted
                                if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                                    msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                                    log.warn msg
                                    if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                                        extraNotifications = true // We need to inform the user
                                    } else {
                                        state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                                        msg = "" // Don't message endlessly
                                    }
                                } else {
                                    deleteCode(lock, user)
                                    msg = "Requesting $lock to delete empty user $user ${name ?: ""}"
                                    log.debug msg
                                }

                                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
                                //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                                startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                                // Last thing to do since it could timeout
                                (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                                return // We are done here, exit out as we've scheduled the next update
                            } else {
                                log.debug "$lock ${name ?: ""} user $user is empty, code already deleted"
                            }
                        	break
                    }
                }

                state.expiredNextCode = state.expiredNextCode + 1 // move onto the next code
            }
            
            // We're done with all the programmed codes for this lock, check of see if any excess codes are left behind from a change in number of user slots and clean them up
            if (state.lockCodes[lock.id]?.any { i, code ->
                def msg = ""
                def extraNotifications = detailedNotifications
                def user = i as Integer
                if (user > maxUserNames) { // This is an excess code, clean it up
                    if ((state.retryCodeCount[lock.id][user as String] = (state.retryCodeCount[lock.id][user as String] ?: 0) + 1) > (maxRetries + 1)) {
                        msg = "Retry programming exceeded, user $user ${name ?: ""} deletion not confirmed by lock $lock"
                        log.warn msg
                        if (state.retryCodeCount[lock.id][user as String] == (maxRetries + 2)) { // Only process it once until reset
                            extraNotifications = true // We need to inform the user
                        } else {
                            state.retryCodeCount[lock.id][user as String] = (maxRetries + 3) // Fix it so when maxRetries changes, it'll pick it up
                            msg = "" // Don't message endlessly
                        }
                    } else {
                        deleteCode(lock, user)
                        msg = "Requesting $lock to delete excess user $user ${name ?: ""}"
                        log.debug msg
                    }

                    //log.trace "Scheduled next code check in ${sendDelay ?: defaultSendDelay} seconds"
                    startTimer((sendDelay ?: defaultSendDelay), codeCheck) // schedule the next code update after a few seconds otherwise it overloads locks and doesn't work

                    // Last thing to do since it could timeout
                    (extraNotifications && msg) ? sendNotifications(msg) : sendNotificationEvent(msg)
                    return true// We are done here, exit out as we've scheduled the next update
                }
            }) { // If had a match then exit as we've scheduled the next iteration
                return // We're done here
            }

            state.expiredLockList.remove(lock.id) // we are done with this lock
            state.expiredNextCode = 1 // reset back to 1 for the next lock
            //log.trace "$lock id $lock.id code check complete, unprocessed locks ${state.expiredLockList}, reset next code update to $state.expiredNextCode"
        }
    }

    // All done now reset the lock list and add the locks back for next check cycle
    state.expiredNextCode = 1 // reset back to 1 for the next lock
    for (lock in locks) {
        state.expiredLockList.add(lock.id) // reset the state for each lock to be processed
        //log.trace "Added $lock id ${lock.id} back to unprocessed locks list ${state.expiredLockList}"
    }
}

// Sets the code on the lock and also updates the username
private setCode(lock, user, code, name) {
    !(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes")) ? lock.setCode(user, code, name) : lock.setCode(user, code) // Keep support for older device handlers
}

// Deletes a code from the lock
private deleteCode(lock, user) {
    lock.deleteCode(user)
}

// Update the name on the lock for a user on a lock
private updateCodeName(lock, user, name) {
    if (!(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes"))) { // Older devices don't have this option
        log.info "Updating user $user name to $name on $lock"
        lock.nameSlot(user, name)
    }
}

// Gets the name of the code on the lock
private getCodeName(lock, user) {
    def name = !(lock.hasAttribute("pinLength") || lock.hasCommand("deleteAllCodes")) ? lock.currentState("lockCodes")?.jsonValue?."$user"?.trim() : null // Older handlers don't support this
    //log.trace "Got name $name from $lock for user $user"
    return name
}

// Kick start the code check routine and download rental data
def kickStart() {
    schedule("* */1 * * * ?", codeCheck) // run codeCheck every 1 minute
    codeCheck()
}

// Heartbeat system to ensure that the MonitorTask doesn't die when it's supposed to be running
def heartBeatMonitor() {
    log.trace "Heartbeat monitor called"

    state.lastHeartBeat = now() // Save the last time we were executed

    log.trace "Last code check was done " + ((now() - (state.lastCheck ?: 0))/1000) + " seconds ago"
    if (((state.lastCheck ?: 0) + (3*60*1000)) < now()) { // Kick start the motion detection monitor if didn't update for more than 3 minutes
        log.warn "Code check hasn't been run a long time, calling it to kick start it"
        kickStart()
    }
    
    // We check for a rental calendar updates once an hour
    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }
    
    if (!state.nextRentalUpdateCheck || (now() >= state.nextRentalUpdateCheck)) { // If we've never run this before then run it now
        downloadRentalData() // Lets get and setup the rental user information
    } else {
        log.trace "Checking for next automatic calendar update after ${(new Date(state.nextRentalUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    }

    // We check for a code update once a day
    if (now() >= state.nextCodeUpdateCheck) {
        // Before checking for code update, calculate the next time we want to check
        state.nextCodeUpdateCheck = (state.nextCodeUpdateCheck ?: now()) + (1*24*60*60*1000) // 1 day from now
        log.info "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
        
        checkForCodeUpdate() // Check for code updates
    } else {
        log.trace "Checking for next app update after ${(new Date(state.nextCodeUpdateCheck)).format("EEE MMM dd yyyy HH:mm z", timeZone)}"
    }
}

def startTimer(seconds, function, dataMap = null) {
    log.trace "Scheduled to run $function in $seconds seconds${dataMap ? " with data $dataMap" : ""}"

    //def runTime = new Date(now() + ((Long)seconds * 1000)) // for runOnce
    //runOnce(runTime, function, [overwrite: true]) // runIn isn't reliable, runOnce is more reliable but isn't as accurate
    if (dataMap) {
        runIn(seconds, function, [overwrite: true, data: dataMap]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    } else {
        runIn(seconds, function, [overwrite: true]) // runOnce is having issues with v2 hubs, hopefully runIn is more stable
    }
}

// Checks if we are within the current operating scheduled
// Inputs to the function are user (i) and schedule (x) (there can be multiple schedules)
// Preferences required in user input settings are:
// settings."userStartTime${x}${i}" - optional
// settings."userEndTime${x}${i}" - optional
// settings."userDayOfWeek${x}${i}" - required
private checkSchedule(def i, def x) {
    log.trace "Checking operating schedule $x for user $i"

    TimeZone timeZone = location.timeZone
    if (!timeZone) {
        timeZone = TimeZone.getDefault()
        def msg = "Hub geolocation not set, using ${timeZone.getDisplayName()} timezone. Use the SmartThings app to set the Hub geolocation to identify the correct timezone."
        log.error msg
        sendPush msg
    }

    def doChange = false
    Calendar localCalendar = Calendar.getInstance(timeZone)
    int currentDayOfWeek = localCalendar.get(Calendar.DAY_OF_WEEK)
    def currentDT = new Date(now())

    // some debugging in order to make sure things are working correclty
    log.trace "Current time: ${currentDT.format("EEE MMM dd yyyy HH:mm z", timeZone)}"

    // Check if we are within operating times
    if (settings."userStartTime${x}${i}" && settings."userEndTime${x}${i}") {
        def scheduledStart = timeToday(settings."userStartTime${x}${i}", timeZone)
        def scheduledEnd = timeToday(settings."userEndTime${x}${i}", timeZone)

        if (scheduledEnd <= scheduledStart) { // End time is next day
            def localHour = currentDT.getHours() + (int)(timeZone.getOffset(currentDT.getTime()) / 1000 / 60 / 60)
            //log.trace "Local hour is $localHour"
            if (( localHour >= 0) && (localHour < 12)) // If we between midnight and midday
            {
                log.trace "End time is before start time and we are past midnight, assuming start time is previous day"
                scheduledStart = scheduledStart.previous() // Get the start time for yesterday
            } else {
                log.trace "End time is before start time and we are past midday, assuming end time is the next day"
                scheduledEnd = scheduledEnd.next() // Get the end time for tomorrow
            }
        }

        log.trace "Operating Start ${scheduledStart.format("HH:mm z", timeZone)}, End ${scheduledEnd.format("HH:mm z", timeZone)}"

        if (currentDT < scheduledStart || currentDT > scheduledEnd) {
            log.debug "Outside operating time schedule"
            return false
        }
    }

    // Check the condition under which we want this to run now
    // This set allows the most flexibility.
    log.trace "Operating DOW(s): ${settings."userDayOfWeek${x}${i}"}"

    if(!settings."userDayOfWeek${x}${i}") {
        log.debug "Day of week not specified for operating schedule $x for user $i"
        return false
    } else if(settings."userDayOfWeek${x}${i}".contains('All Week')) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Monday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.MONDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Tuesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.TUESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Wednesday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.WEDNESDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Thursday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.THURSDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Friday') || settings."userDayOfWeek${x}${i}".contains('Monday to Friday')) && currentDayOfWeek == Calendar.instance.FRIDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Saturday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SATURDAY) {
        doChange = true
    } else if((settings."userDayOfWeek${x}${i}".contains('Sunday') || settings."userDayOfWeek${x}${i}".contains('Saturday & Sunday')) && currentDayOfWeek == Calendar.instance.SUNDAY) {
        doChange = true
    }

    // If we have hit the condition to schedule this then lets do it
    if(doChange == true){
        log.debug("Within operating schedule")
        return true
    }
    else {
        log.debug("Outside operating schedule")
        return false
    }
}

private void sendText(number, message) {
    if (number) {
        def phones = number.replaceAll("[;,#]", "*").split("\\*") // Some users accidentally use ;,# instead of * and ST can't handle *,#+ in the number except for + at the beginning
        for (phone in phones) {
            try {
                sendSms(phone, message)
            } catch (Exception e) {
                sendPush "Invalid phone number $phone"
            }
        }
    }
}

private void sendNotifications(message, user = "") {
	if (!message) {
		return
    }
    
    if (location.contactBookEnabled) {
        sendNotificationToContacts(message, settings."recipients${user}")
    } else {
        if (!settings."disableAllNotify${user}") {
            sendPush message
        } else {
            sendNotificationEvent(message)
        }
        if (settings."sms${user}") {
            sendText(settings."sms${user}", message)
        }
    }

    settings."audioDevices${user}"?.each { audioDevice -> // Play audio notifications
        if (audioDevice.hasCommand("playText")) { // Check if it supports TTS
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTextAndResume(message, audioVolume)
            } else {
                audioDevice.playText(message)
            }
        } else {
            if (audioVolume) { // Only set volume if defined as it also resumes playback
                audioDevice.playTrackAndResume(textToSpeech(message)?.uri, audioVolume) // No translations at this time
            } else {
                audioDevice.playTrack(textToSpeech(message)?.uri) // No translations at this time
            }
        }
    }
}

// Extracts the 'key' value from the string 'str' given the 'token' separater and end of marker 'delimiter'
// If 'delimiter' is '<unfold>` then follow RFC 5545 to unfold the line - https://icalendar.org/iCalendar-RFC-5545/3-1-content-lines.html
private getKeyValue(str, key, token, delimiter) {
    def valStr = ""

    if (!str?.contains(key)) { // Start key not found
        return valStr
    }

    def startKey = str.indexOf(key)
    def endKey = str.indexOf(token, startKey)
    if (endKey == -1) { // Token not found
        return valStr
    }
    //def keyStr = str?.substring(startKey, endKey)?.trim()
    def startVal = endKey + 1
    if (delimiter == "<unfold>") {
        def lines = str.substring(startVal)?.replace("\r", "")?.split("\n")?.toList() // Remove any CR and split by LF
        valStr = lines?.removeAt(0) // Keep the first line starting with token
        for (line in lines) {
            if (line.startsWith(" ") || line.startsWith("\t")) {
                valStr += line.substring(1) // Drop the first character (space or tab)
            } else {
                break // Collect all entries that start with a space or tab and then stop when none encountered
            }
        }
    } else {
        def endVal = delimiter ? str.indexOf(delimiter, startVal) : str.size() // If don't have a delimiter, assume it's till the end of the string
        valStr = (endVal > startVal) ? str.substring(startVal, endVal)?.trim() : str.substring(startVal)?.trim() // If the delimiter can't be found then assume it's till end of the string
    }

    //log.trace valStr

    return valStr
}

private strToMap(str, token, delimiter) {
    // Split on delimiter to get a List
    str?.split(delimiter)?.collectEntries { entry -> // Each list item is transformed to a Map entry with key/value.
        def pair = entry.split(token)
        [(pair.first()): pair.last()]
    }
}

// Check if we are within the rental programming notification time limits if defined, if not then it's always true
private withinRentalProgrammingNotificationTimes() {
    if (rentalProgrammingNotificationsStart && rentalProgrammingNotificationsEnd) {
        // def tZ = getTimeZone(rentalProgrammingNotificationsStart) // Use phone timeZone
        def tZ = getTimeZone() // Use hub timezone since phone can keep moving around, this way it's fixed
        def start = timeToday(rentalProgrammingNotificationsStart, tZ)
        def end = timeToday(rentalProgrammingNotificationsEnd, tZ)
        if (end < start) { // Move end to next day
        	end = end + 1
        }
        return timeOfDayIsBetween(timeToday(rentalProgrammingNotificationsStart, tZ), timeToday(rentalProgrammingNotificationsEnd, tZ), new Date(now()), tZ)
    } else {
        return true // We are always within 
    }
}

// Cleans the URL to start and ensures it starts with https
private cleanSecureUrl(url) {
    return (url?.trim().startsWith("http://") ? url?.trim().replaceFirst("http://", "https://") : !url?.trim().startsWith("https://") ? "https://" + url : url)?.trim()
}

// Gets the timezone of the mobile phone time input setting if passed or the hub timezone
private getTimeZone(timeSetting = null) {
    if (timeSetting) {
        return timeZone(timeSetting) // Extract the phone setting timezone
    } else {
        return location.timeZone ?: TimeZone.getDefault() // Use location timezone or default timezone if location it's not set
    }
}

// Returns a list of users who have the same user code as the user
private getDuplicateCodeUsers(allUserCodes, i) {
    allUserCodes.groupBy { it.value }.findAll { (it.key) && (it.value.size() > 1) && (it.value*.key).contains(i) }*.value*.keySet()?.flatten() - i
}

// Override the user settings
// Update a single setting
private updateSetting(name, value) {
    app.updateSetting(name, value) // For SmartApps UI - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB
    settings[name] = value // For Device Handlers and SmartApps - much faster but only works on uninitialized value (once the user updates it this approach won't work)
}

// Update multiple settings passed in a map
private updateSettings(map) {
    app.updateSettings(map)
    map.each { name, value -> // Force the DB to reload new values
        settings[name] = value
    }
}

// Delete a single setting
private deleteSetting(name) {
    //app.deleteSetting(name) // For SmartApps delete it, TODO: Gives and error - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB (don't mix app and settings approach or it causes corruption)
    //settings.remove(name) // For Device Handlers
    app.updateSetting(name, '') // For SmartApps - THIS IS A VERY SLOW TRANSACTION as it writes directly to the DB (don't mix app and settings approach or it causes corruption)
    settings[name] = '' // For Device Handlers and SmartApps - much faster but only works on uninitialized value (once the user updates it this approach won't work)
}

// Delete multiple settings passed in an array
private deleteSettings(map) {
    def mapValues = [:]
    map.each { mapValues[it] = '' }
    app.updateSettings(mapValues)
    map.each { name -> // Force the DB to reload new values
        settings[name] = '' 
    }
}

private loginCheck() {
    log.trace "Login check"
	
    authUpdate("check") { resp ->
        if (resp?.status == 401) { // Invalid username
            state.loginError = "Invalid username" // No response from website - we should not be here
            state.loginSuccess = false
        } else if ((resp?.status == 200) && resp?.data) {
            def ret = resp.data
            if (ret?.Authenticated) {
                state.loginError = ""
                state.loginSuccess = true
            } else {
                state.loginError = ret?.Error
                state.loginSuccess = false
            }
        } else {
            state.loginError = "Unable to authenticate license, please try again later" // No response from website - we should not be here
            state.loginSuccess = false
        }
    }
}

private authUpdate(String action, Closure closure = null) {
    if (!username) {
    	return
    }
    
    def params = [
        uri: "https://auth.rboyapps.com/v1/license",
        headers: [
            Authorization: "Basic ${"${username?.trim()?.toLowerCase()}:${username?.trim()?.toLowerCase()}".getBytes().encodeBase64()}",
        ],
        body: [
            AppId: app.id,
            Timestamp: new Date(now()).format("yyyy-MM-dd'T'HH:mm:ssXXX", location.timeZone ?: TimeZone.getDefault()), // ISO_8601
            State: action,
            Username: username?.trim()?.toLowerCase(),
            LocationId: location.id,
            LocationName: location.name,
            AccountId: app.accountId,
            AppName: "Rental Lock Automater",
            AppInstallName: app.label,
            AppVersion: clientVersion(),
        ]
    ]
    
    log.trace "Calling AuthUpdate\n${params}"

    try {
        httpPostJson(params) { resp ->
            /*resp?.headers.each {
                log.trace "${it.name} : ${it.value}"
            }
            log.trace "response contentType: ${resp?.contentType}"*/
            log.debug "response data: ${resp?.data}"
            if (closure) {
                closure(resp)
            }
        }
    } catch (e) {
        //log.error "Auth response:\n${e.response?.data}\n\n${e.response?.allHeaders}\n\n${e.response?.status}\n\n${e.response?.statusLine}\n\n$e"
        if ("${e}"?.contains("HttpResponseException")) { // If it's a HTTP error with non 200 status
            log.warn "Auth status: ${e?.response?.status}, response: ${e?.response?.statusLine}"
            if (closure) {
                closure(e?.response)
            }
        } else { // Some other error
            log.error "Auth error: $e"
            if (closure) {
                closure(null)
            }
        }
    }
}

def checkForCodeUpdate(evt = null) {
    log.trace "Getting latest version data from the RBoy Apps server"
    
    def appName = "Rental Lock Automater X"
    def serverUrl = "http://smartthings.rboyapps.com"
    def serverPath = "/CodeVersions.json"
    
    try {
        httpGet([
            uri: serverUrl,
            path: serverPath
        ]) { ret ->
            log.trace "Received response from RBoy Apps Server, headers=${ret.headers.'Content-Type'}, status=$ret.status"
            //ret.headers.each {
            //    log.trace "${it.name} : ${it.value}"
            //}

            if (ret.data) {
                log.trace "Response>" + ret.data
                
                // Check for app version updates
                def appVersion = ret.data?."$appName"?.version
                def appMsg = ret.data?."$appName"?.message
                def criticalMsg = ret.data?."$appName"?.criticalMessage
                if (criticalMsg) { // If we have a critical message display it to the user
                    log.info "CRITICAL MESSAGE: $criticalMsg"
                    sendPush(criticalMsg)
                }
                if (appVersion > clientVersion()) {
                    def msg = (appMsg ? appMsg + "\n" : "") + "Update ${app.label} to version $appVersion (current ${clientVersion()}).\nDownload the latest version from www.rboyapps.com."
                    log.info msg
                    if (updateNotifications != false) { // The default true may not be registered
                        sendPush(msg)
                    }
                } else {
                    log.trace "No new app version found, latest version: $appVersion"
                }
                
                // Check device handler version updates
                def devices = locks?.findAll { it.hasAttribute("codeVersion") }
                for (device in devices) {
                    if (device) {
                        def deviceName = device?.currentValue("dhName")
                        def deviceVersion = ret.data?."$deviceName"
                        if (deviceVersion && (deviceVersion > device?.currentValue("codeVersion"))) {
                            def msg = "Update ${device?.displayName} device handler to version $deviceVersion, current version: ${device?.currentValue("codeVersion")}.\nVisit www.rboyapps.com to get the latest version of $deviceName."
                            log.info msg
                            if (updateNotifications != false) { // The default true may not be registered
                                sendPush(msg)
                            }
                        } else {
                            log.trace "No new device version found for $deviceName, latest version: $deviceVersion, current version: ${device?.currentValue("codeVersion")}"
                        }
                    }
                }
            } else {
                log.error "No response to query"
            }
        }
    } catch (e) {
        log.error "Exception while querying latest app version: $e"
    }
}

// THIS IS THE END OF THE FILE

